/*
Arvan LIVE

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package live

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AnalyticsAPIService AnalyticsAPI service
type AnalyticsAPIService service

type ApiAnalyticsPlayCountGetRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	period *string
	since *string
	until *string
	interval *string
	orderByName *string
	orderByOrder *string
	groupBy *string
	limit *int32
	offset *int32
	aggregate *string
	timezone *string
	filtersStream *[]string
	filtersCountry *[]string
	filtersAsn *[]string
	filtersClientType *[]string
	filtersClientFamily *[]string
	filtersOsFamily *[]string
	filtersDeviceType *[]string
	filtersDeviceBrand *[]string
	filtersDeviceModel *[]string
	filtersResolution *[]string
}

// Enum: &#39;1h&#39; &#39;2h&#39; &#39;3h&#39; &#39;6h&#39; &#39;12h&#39; &#39;24h&#39; &#39;3d&#39; &#39;7d&#39; &#39;14d&#39; &#39;1m&#39; 
func (r ApiAnalyticsPlayCountGetRequest) Period(period string) ApiAnalyticsPlayCountGetRequest {
	r.period = &period
	return r
}

// string &lt;date-time:Y-m-d H:i&gt;|&lt;date: Y-m-d&gt;
func (r ApiAnalyticsPlayCountGetRequest) Since(since string) ApiAnalyticsPlayCountGetRequest {
	r.since = &since
	return r
}

// string &lt;date-time:Y-m-d H:i&gt;|&lt;date: Y-m-d&gt;
func (r ApiAnalyticsPlayCountGetRequest) Until(until string) ApiAnalyticsPlayCountGetRequest {
	r.until = &until
	return r
}

// Enum: &#39;minutely&#39; &#39;hourly&#39; &#39;daily&#39;
func (r ApiAnalyticsPlayCountGetRequest) Interval(interval string) ApiAnalyticsPlayCountGetRequest {
	r.interval = &interval
	return r
}

// Enum: watch_time
func (r ApiAnalyticsPlayCountGetRequest) OrderByName(orderByName string) ApiAnalyticsPlayCountGetRequest {
	r.orderByName = &orderByName
	return r
}

// Enum: &#39;ASC&#39; &#39;DESC&#39;
func (r ApiAnalyticsPlayCountGetRequest) OrderByOrder(orderByOrder string) ApiAnalyticsPlayCountGetRequest {
	r.orderByOrder = &orderByOrder
	return r
}

// Enum: &#39;channel&#39; &#39;video&#39; &#39;country&#39; &#39;asn&#39;
func (r ApiAnalyticsPlayCountGetRequest) GroupBy(groupBy string) ApiAnalyticsPlayCountGetRequest {
	r.groupBy = &groupBy
	return r
}

// Limit the number of entities
func (r ApiAnalyticsPlayCountGetRequest) Limit(limit int32) ApiAnalyticsPlayCountGetRequest {
	r.limit = &limit
	return r
}

// Define offset of entities
func (r ApiAnalyticsPlayCountGetRequest) Offset(offset int32) ApiAnalyticsPlayCountGetRequest {
	r.offset = &offset
	return r
}

// Enum: &#39;SUM&#39; &#39;AVG&#39; &#39;MIN&#39; &#39;MAX&#39; &#39;COUNT&#39;
func (r ApiAnalyticsPlayCountGetRequest) Aggregate(aggregate string) ApiAnalyticsPlayCountGetRequest {
	r.aggregate = &aggregate
	return r
}

// Timezone ex: Asia/Tehran
func (r ApiAnalyticsPlayCountGetRequest) Timezone(timezone string) ApiAnalyticsPlayCountGetRequest {
	r.timezone = &timezone
	return r
}

// Filter by stream IDs
func (r ApiAnalyticsPlayCountGetRequest) FiltersStream(filtersStream []string) ApiAnalyticsPlayCountGetRequest {
	r.filtersStream = &filtersStream
	return r
}

// Filter by country IDs
func (r ApiAnalyticsPlayCountGetRequest) FiltersCountry(filtersCountry []string) ApiAnalyticsPlayCountGetRequest {
	r.filtersCountry = &filtersCountry
	return r
}

// Filter by asn numbers
func (r ApiAnalyticsPlayCountGetRequest) FiltersAsn(filtersAsn []string) ApiAnalyticsPlayCountGetRequest {
	r.filtersAsn = &filtersAsn
	return r
}

// Filter by client type
func (r ApiAnalyticsPlayCountGetRequest) FiltersClientType(filtersClientType []string) ApiAnalyticsPlayCountGetRequest {
	r.filtersClientType = &filtersClientType
	return r
}

// Filter by client family
func (r ApiAnalyticsPlayCountGetRequest) FiltersClientFamily(filtersClientFamily []string) ApiAnalyticsPlayCountGetRequest {
	r.filtersClientFamily = &filtersClientFamily
	return r
}

// Filter by os family
func (r ApiAnalyticsPlayCountGetRequest) FiltersOsFamily(filtersOsFamily []string) ApiAnalyticsPlayCountGetRequest {
	r.filtersOsFamily = &filtersOsFamily
	return r
}

// Filter by device type
func (r ApiAnalyticsPlayCountGetRequest) FiltersDeviceType(filtersDeviceType []string) ApiAnalyticsPlayCountGetRequest {
	r.filtersDeviceType = &filtersDeviceType
	return r
}

// Filter by device brand
func (r ApiAnalyticsPlayCountGetRequest) FiltersDeviceBrand(filtersDeviceBrand []string) ApiAnalyticsPlayCountGetRequest {
	r.filtersDeviceBrand = &filtersDeviceBrand
	return r
}

// Filter by device model
func (r ApiAnalyticsPlayCountGetRequest) FiltersDeviceModel(filtersDeviceModel []string) ApiAnalyticsPlayCountGetRequest {
	r.filtersDeviceModel = &filtersDeviceModel
	return r
}

// Filter by resolution
func (r ApiAnalyticsPlayCountGetRequest) FiltersResolution(filtersResolution []string) ApiAnalyticsPlayCountGetRequest {
	r.filtersResolution = &filtersResolution
	return r
}

func (r ApiAnalyticsPlayCountGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnalyticsPlayCountGetExecute(r)
}

/*
AnalyticsPlayCountGet Return appropriate play count

Interval constraint
                        - Max 'daily' : 30d
                        - Max 'hourly' : 2d
                        - Max 'minutely' : 2h
                        <br/>
                        Period constraint
                        - Max : 30d
                        <br/>
                        Since and until constraint
                        - Max of date format : 30d
                        - Max of date-time format : 2d
                        - The format of both should be the same either as date-time or as date.
                        <br/>
                        Aggregate constraint
                        - It should be used with group_by or interval.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnalyticsPlayCountGetRequest
*/
func (a *AnalyticsAPIService) AnalyticsPlayCountGet(ctx context.Context) ApiAnalyticsPlayCountGetRequest {
	return ApiAnalyticsPlayCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AnalyticsAPIService) AnalyticsPlayCountGetExecute(r ApiAnalyticsPlayCountGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.AnalyticsPlayCountGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/play-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Period", r.period, "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "")
	}
	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "")
	}
	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.orderByName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by.name", r.orderByName, "")
	}
	if r.orderByOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by.order", r.orderByOrder, "")
	}
	if r.groupBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", r.groupBy, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.aggregate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate", r.aggregate, "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "")
	}
	if r.filtersStream != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.stream", r.filtersStream, "csv")
	}
	if r.filtersCountry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.country", r.filtersCountry, "csv")
	}
	if r.filtersAsn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.asn", r.filtersAsn, "csv")
	}
	if r.filtersClientType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.client_type", r.filtersClientType, "csv")
	}
	if r.filtersClientFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.client_family", r.filtersClientFamily, "csv")
	}
	if r.filtersOsFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.os_family", r.filtersOsFamily, "csv")
	}
	if r.filtersDeviceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.device_type", r.filtersDeviceType, "csv")
	}
	if r.filtersDeviceBrand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.device_brand", r.filtersDeviceBrand, "csv")
	}
	if r.filtersDeviceModel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.device_model", r.filtersDeviceModel, "csv")
	}
	if r.filtersResolution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.resolution", r.filtersResolution, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAnalyticsTrafficGetRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	period *string
	since *string
	until *string
	interval *string
	orderByName *string
	orderByOrder *string
	groupBy *string
	limit *int32
	offset *int32
	aggregate *string
	timezone *string
	filtersStream *[]string
	filtersCountry *[]string
	filtersAsn *[]string
	filtersClientType *[]string
	filtersClientFamily *[]string
	filtersOsFamily *[]string
	filtersDeviceType *[]string
	filtersDeviceBrand *[]string
	filtersDeviceModel *[]string
	filtersResolution *[]string
}

// Enum: &#39;1h&#39; &#39;2h&#39; &#39;3h&#39; &#39;6h&#39; &#39;12h&#39; &#39;24h&#39; &#39;3d&#39; &#39;7d&#39; &#39;14d&#39; &#39;1m&#39;
func (r ApiAnalyticsTrafficGetRequest) Period(period string) ApiAnalyticsTrafficGetRequest {
	r.period = &period
	return r
}

// string &lt;date-time:Y-m-d H:i&gt;|&lt;date: Y-m-d&gt;
func (r ApiAnalyticsTrafficGetRequest) Since(since string) ApiAnalyticsTrafficGetRequest {
	r.since = &since
	return r
}

// string &lt;date-time:Y-m-d H:i&gt;|&lt;date: Y-m-d&gt;
func (r ApiAnalyticsTrafficGetRequest) Until(until string) ApiAnalyticsTrafficGetRequest {
	r.until = &until
	return r
}

// Enum: &#39;minutely&#39; &#39;hourly&#39; &#39;daily&#39;
func (r ApiAnalyticsTrafficGetRequest) Interval(interval string) ApiAnalyticsTrafficGetRequest {
	r.interval = &interval
	return r
}

// Enum: traffic
func (r ApiAnalyticsTrafficGetRequest) OrderByName(orderByName string) ApiAnalyticsTrafficGetRequest {
	r.orderByName = &orderByName
	return r
}

// Enum: &#39;ASC&#39; &#39;DESC&#39;
func (r ApiAnalyticsTrafficGetRequest) OrderByOrder(orderByOrder string) ApiAnalyticsTrafficGetRequest {
	r.orderByOrder = &orderByOrder
	return r
}

// Enum: &#39;channel&#39; &#39;video&#39; &#39;country&#39; &#39;asn&#39; &#39;referer&#39;
func (r ApiAnalyticsTrafficGetRequest) GroupBy(groupBy string) ApiAnalyticsTrafficGetRequest {
	r.groupBy = &groupBy
	return r
}

// Limit the number of entities
func (r ApiAnalyticsTrafficGetRequest) Limit(limit int32) ApiAnalyticsTrafficGetRequest {
	r.limit = &limit
	return r
}

// Define offset of entities
func (r ApiAnalyticsTrafficGetRequest) Offset(offset int32) ApiAnalyticsTrafficGetRequest {
	r.offset = &offset
	return r
}

// Enum: &#39;SUM&#39; &#39;AVG&#39; &#39;MIN&#39; &#39;MAX&#39; &#39;COUNT&#39;
func (r ApiAnalyticsTrafficGetRequest) Aggregate(aggregate string) ApiAnalyticsTrafficGetRequest {
	r.aggregate = &aggregate
	return r
}

// Timezone ex: Asia/Tehran
func (r ApiAnalyticsTrafficGetRequest) Timezone(timezone string) ApiAnalyticsTrafficGetRequest {
	r.timezone = &timezone
	return r
}

// Filter by stream IDs
func (r ApiAnalyticsTrafficGetRequest) FiltersStream(filtersStream []string) ApiAnalyticsTrafficGetRequest {
	r.filtersStream = &filtersStream
	return r
}

// Filter by country IDs
func (r ApiAnalyticsTrafficGetRequest) FiltersCountry(filtersCountry []string) ApiAnalyticsTrafficGetRequest {
	r.filtersCountry = &filtersCountry
	return r
}

// Filter by asn numbers
func (r ApiAnalyticsTrafficGetRequest) FiltersAsn(filtersAsn []string) ApiAnalyticsTrafficGetRequest {
	r.filtersAsn = &filtersAsn
	return r
}

// Filter by client type
func (r ApiAnalyticsTrafficGetRequest) FiltersClientType(filtersClientType []string) ApiAnalyticsTrafficGetRequest {
	r.filtersClientType = &filtersClientType
	return r
}

// Filter by client family
func (r ApiAnalyticsTrafficGetRequest) FiltersClientFamily(filtersClientFamily []string) ApiAnalyticsTrafficGetRequest {
	r.filtersClientFamily = &filtersClientFamily
	return r
}

// Filter by os family
func (r ApiAnalyticsTrafficGetRequest) FiltersOsFamily(filtersOsFamily []string) ApiAnalyticsTrafficGetRequest {
	r.filtersOsFamily = &filtersOsFamily
	return r
}

// Filter by device type
func (r ApiAnalyticsTrafficGetRequest) FiltersDeviceType(filtersDeviceType []string) ApiAnalyticsTrafficGetRequest {
	r.filtersDeviceType = &filtersDeviceType
	return r
}

// Filter by device brand
func (r ApiAnalyticsTrafficGetRequest) FiltersDeviceBrand(filtersDeviceBrand []string) ApiAnalyticsTrafficGetRequest {
	r.filtersDeviceBrand = &filtersDeviceBrand
	return r
}

// Filter by device model
func (r ApiAnalyticsTrafficGetRequest) FiltersDeviceModel(filtersDeviceModel []string) ApiAnalyticsTrafficGetRequest {
	r.filtersDeviceModel = &filtersDeviceModel
	return r
}

// Filter by resolution
func (r ApiAnalyticsTrafficGetRequest) FiltersResolution(filtersResolution []string) ApiAnalyticsTrafficGetRequest {
	r.filtersResolution = &filtersResolution
	return r
}

func (r ApiAnalyticsTrafficGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnalyticsTrafficGetExecute(r)
}

/*
AnalyticsTrafficGet Return appropriate traffic

Interval constraint
                        - Max 'daily' : 30d
                        - Max 'hourly' : 2d
                        - Max 'minutely' : 2h
                        <br/>
                        Period constraint
                        - Max : 30d
                        <br/>
                        Since and until constraint
                        - Max of date format : 30d
                        - Max of date-time format : 2d
                        - The format of both should be the same either as date-time or as date.
                        <br/>
                        Aggregate constraint
                        - It should be used with group_by or interval.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnalyticsTrafficGetRequest
*/
func (a *AnalyticsAPIService) AnalyticsTrafficGet(ctx context.Context) ApiAnalyticsTrafficGetRequest {
	return ApiAnalyticsTrafficGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AnalyticsAPIService) AnalyticsTrafficGetExecute(r ApiAnalyticsTrafficGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.AnalyticsTrafficGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/traffic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Period", r.period, "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "")
	}
	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "")
	}
	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.orderByName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by.name", r.orderByName, "")
	}
	if r.orderByOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by.order", r.orderByOrder, "")
	}
	if r.groupBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", r.groupBy, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.aggregate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate", r.aggregate, "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "")
	}
	if r.filtersStream != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.stream", r.filtersStream, "csv")
	}
	if r.filtersCountry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.country", r.filtersCountry, "csv")
	}
	if r.filtersAsn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.asn", r.filtersAsn, "csv")
	}
	if r.filtersClientType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.client_type", r.filtersClientType, "csv")
	}
	if r.filtersClientFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.client_family", r.filtersClientFamily, "csv")
	}
	if r.filtersOsFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.os_family", r.filtersOsFamily, "csv")
	}
	if r.filtersDeviceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.device_type", r.filtersDeviceType, "csv")
	}
	if r.filtersDeviceBrand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.device_brand", r.filtersDeviceBrand, "csv")
	}
	if r.filtersDeviceModel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.device_model", r.filtersDeviceModel, "csv")
	}
	if r.filtersResolution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.resolution", r.filtersResolution, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAnalyticsWatchTimeGetRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	period *string
	since *string
	until *string
	interval *string
	orderByName *string
	orderByOrder *string
	groupBy *string
	limit *int32
	offset *int32
	aggregate *string
	timezone *string
	filtersStream *[]string
	filtersCountry *[]string
	filtersAsn *[]string
	filtersClientType *[]string
	filtersClientFamily *[]string
	filtersOsFamily *[]string
	filtersDeviceType *[]string
	filtersDeviceBrand *[]string
	filtersDeviceModel *[]string
	filtersResolution *[]string
}

// Enum: &#39;1h&#39; &#39;2h&#39; &#39;3h&#39; &#39;6h&#39; &#39;12h&#39; &#39;24h&#39; &#39;3d&#39; &#39;7d&#39; &#39;14d&#39; &#39;1m&#39;
func (r ApiAnalyticsWatchTimeGetRequest) Period(period string) ApiAnalyticsWatchTimeGetRequest {
	r.period = &period
	return r
}

// string &lt;date-time:Y-m-d H:i&gt;|&lt;date: Y-m-d&gt;
func (r ApiAnalyticsWatchTimeGetRequest) Since(since string) ApiAnalyticsWatchTimeGetRequest {
	r.since = &since
	return r
}

// string &lt;date-time:Y-m-d H:i&gt;|&lt;date: Y-m-d&gt;
func (r ApiAnalyticsWatchTimeGetRequest) Until(until string) ApiAnalyticsWatchTimeGetRequest {
	r.until = &until
	return r
}

// Enum: &#39;minutely&#39; &#39;hourly&#39; &#39;daily&#39;
func (r ApiAnalyticsWatchTimeGetRequest) Interval(interval string) ApiAnalyticsWatchTimeGetRequest {
	r.interval = &interval
	return r
}

// Enum: watch_time
func (r ApiAnalyticsWatchTimeGetRequest) OrderByName(orderByName string) ApiAnalyticsWatchTimeGetRequest {
	r.orderByName = &orderByName
	return r
}

// Enum: &#39;ASC&#39; &#39;DESC&#39;
func (r ApiAnalyticsWatchTimeGetRequest) OrderByOrder(orderByOrder string) ApiAnalyticsWatchTimeGetRequest {
	r.orderByOrder = &orderByOrder
	return r
}

// Enum: &#39;channel&#39; &#39;video&#39; &#39;country&#39; &#39;asn&#39;
func (r ApiAnalyticsWatchTimeGetRequest) GroupBy(groupBy string) ApiAnalyticsWatchTimeGetRequest {
	r.groupBy = &groupBy
	return r
}

// Limit the number of entities
func (r ApiAnalyticsWatchTimeGetRequest) Limit(limit int32) ApiAnalyticsWatchTimeGetRequest {
	r.limit = &limit
	return r
}

// Define offset of entities
func (r ApiAnalyticsWatchTimeGetRequest) Offset(offset int32) ApiAnalyticsWatchTimeGetRequest {
	r.offset = &offset
	return r
}

// Enum: &#39;SUM&#39; &#39;AVG&#39; &#39;MIN&#39; &#39;MAX&#39; &#39;COUNT&#39;
func (r ApiAnalyticsWatchTimeGetRequest) Aggregate(aggregate string) ApiAnalyticsWatchTimeGetRequest {
	r.aggregate = &aggregate
	return r
}

// Timezone ex: Asia/Tehran
func (r ApiAnalyticsWatchTimeGetRequest) Timezone(timezone string) ApiAnalyticsWatchTimeGetRequest {
	r.timezone = &timezone
	return r
}

// Filter by stream IDs
func (r ApiAnalyticsWatchTimeGetRequest) FiltersStream(filtersStream []string) ApiAnalyticsWatchTimeGetRequest {
	r.filtersStream = &filtersStream
	return r
}

// Filter by country IDs
func (r ApiAnalyticsWatchTimeGetRequest) FiltersCountry(filtersCountry []string) ApiAnalyticsWatchTimeGetRequest {
	r.filtersCountry = &filtersCountry
	return r
}

// Filter by asn numbers
func (r ApiAnalyticsWatchTimeGetRequest) FiltersAsn(filtersAsn []string) ApiAnalyticsWatchTimeGetRequest {
	r.filtersAsn = &filtersAsn
	return r
}

// Filter by client type
func (r ApiAnalyticsWatchTimeGetRequest) FiltersClientType(filtersClientType []string) ApiAnalyticsWatchTimeGetRequest {
	r.filtersClientType = &filtersClientType
	return r
}

// Filter by client family
func (r ApiAnalyticsWatchTimeGetRequest) FiltersClientFamily(filtersClientFamily []string) ApiAnalyticsWatchTimeGetRequest {
	r.filtersClientFamily = &filtersClientFamily
	return r
}

// Filter by os family
func (r ApiAnalyticsWatchTimeGetRequest) FiltersOsFamily(filtersOsFamily []string) ApiAnalyticsWatchTimeGetRequest {
	r.filtersOsFamily = &filtersOsFamily
	return r
}

// Filter by device type
func (r ApiAnalyticsWatchTimeGetRequest) FiltersDeviceType(filtersDeviceType []string) ApiAnalyticsWatchTimeGetRequest {
	r.filtersDeviceType = &filtersDeviceType
	return r
}

// Filter by device brand
func (r ApiAnalyticsWatchTimeGetRequest) FiltersDeviceBrand(filtersDeviceBrand []string) ApiAnalyticsWatchTimeGetRequest {
	r.filtersDeviceBrand = &filtersDeviceBrand
	return r
}

// Filter by device model
func (r ApiAnalyticsWatchTimeGetRequest) FiltersDeviceModel(filtersDeviceModel []string) ApiAnalyticsWatchTimeGetRequest {
	r.filtersDeviceModel = &filtersDeviceModel
	return r
}

// Filter by resolution
func (r ApiAnalyticsWatchTimeGetRequest) FiltersResolution(filtersResolution []string) ApiAnalyticsWatchTimeGetRequest {
	r.filtersResolution = &filtersResolution
	return r
}

func (r ApiAnalyticsWatchTimeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnalyticsWatchTimeGetExecute(r)
}

/*
AnalyticsWatchTimeGet Return appropriate watch time

Interval constraint
                        - Max 'daily' : 30d
                        - Max 'hourly' : 2d
                        - Max 'minutely' : 2h
                        <br/>
                        Period constraint
                        - Max : 30d
                        <br/>
                        Since and until constraint
                        - Max of date format : 30d
                        - Max of date-time format : 2d
                        - The format of both should be the same either as date-time or as date.
                        <br/>
                        Aggregate constraint
                        - It should be used with group_by or interval.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnalyticsWatchTimeGetRequest
*/
func (a *AnalyticsAPIService) AnalyticsWatchTimeGet(ctx context.Context) ApiAnalyticsWatchTimeGetRequest {
	return ApiAnalyticsWatchTimeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AnalyticsAPIService) AnalyticsWatchTimeGetExecute(r ApiAnalyticsWatchTimeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.AnalyticsWatchTimeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/watch-time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Period", r.period, "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "")
	}
	if r.until != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "until", r.until, "")
	}
	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	if r.orderByName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by.name", r.orderByName, "")
	}
	if r.orderByOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by.order", r.orderByOrder, "")
	}
	if r.groupBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", r.groupBy, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.aggregate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate", r.aggregate, "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "")
	}
	if r.filtersStream != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.stream", r.filtersStream, "csv")
	}
	if r.filtersCountry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.country", r.filtersCountry, "csv")
	}
	if r.filtersAsn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.asn", r.filtersAsn, "csv")
	}
	if r.filtersClientType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.client_type", r.filtersClientType, "csv")
	}
	if r.filtersClientFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.client_family", r.filtersClientFamily, "csv")
	}
	if r.filtersOsFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.os_family", r.filtersOsFamily, "csv")
	}
	if r.filtersDeviceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.device_type", r.filtersDeviceType, "csv")
	}
	if r.filtersDeviceBrand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.device_brand", r.filtersDeviceBrand, "csv")
	}
	if r.filtersDeviceModel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.device_model", r.filtersDeviceModel, "csv")
	}
	if r.filtersResolution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters.resolution", r.filtersResolution, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
