/*
ArvanCloud S3 Services

<p/>

API version: 2006-03-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package storage

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// ObjectAPIService ObjectAPI service
type ObjectAPIService service

type ApiDeleteObjectRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	bucket string
	key string
	xAmzSecurityToken *string
	xAmzMfa *string
	versionId *string
	xAmzRequestPayer *string
	xAmzBypassGovernanceRetention *bool
	xAmzExpectedBucketOwner *string
}

// This parameter is currently not supported and is not required.
func (r ApiDeleteObjectRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiDeleteObjectRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// The concatenation of the authentication device&#39;s serial number, a space, and the value that is displayed on your authentication device. Required to permanently delete a versioned object if versioning is configured with MFA delete enabled.
func (r ApiDeleteObjectRequest) XAmzMfa(xAmzMfa string) ApiDeleteObjectRequest {
	r.xAmzMfa = &xAmzMfa
	return r
}

// VersionId used to reference a specific version of the object.
func (r ApiDeleteObjectRequest) VersionId(versionId string) ApiDeleteObjectRequest {
	r.versionId = &versionId
	return r
}

// 
func (r ApiDeleteObjectRequest) XAmzRequestPayer(xAmzRequestPayer string) ApiDeleteObjectRequest {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

// Indicates whether S3 Object Lock should bypass Governance-mode restrictions to process this operation. To use this header, you must have the &lt;code&gt;s3:PutBucketPublicAccessBlock&lt;/code&gt; permission.
func (r ApiDeleteObjectRequest) XAmzBypassGovernanceRetention(xAmzBypassGovernanceRetention bool) ApiDeleteObjectRequest {
	r.xAmzBypassGovernanceRetention = &xAmzBypassGovernanceRetention
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiDeleteObjectRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiDeleteObjectRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiDeleteObjectRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteObjectExecute(r)
}

/*
DeleteObject Method for DeleteObject

<p>Removes the null version (if there is one) of an object and inserts a delete marker, which becomes the latest version of the object. If there isn't a null version, ArvanCloud S3 does not remove any objects but will still respond that the command was successful.</p> <p>To remove a specific version, you must be the bucket owner and you must use the version Id subresource. Using this subresource permanently deletes the version. If the object deleted is a delete marker, ArvanCloud S3 sets the response header, <code>x-amz-delete-marker</code>, to true. </p> <p>If the object you want to delete is in a bucket where the bucket versioning configuration is MFA Delete enabled, you must include the <code>x-amz-mfa</code> request header in the DELETE <code>versionId</code> request. Requests that include <code>x-amz-mfa</code> must use HTTPS. </p>  <p>You can delete objects by explicitly calling DELETE Object or configure its lifecycle (<a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketLifecycle.html">PutBucketLifecycle</a>) to enable ArvanCloud S3 to remove them for you. If you want to block users or accounts from removing or deleting objects from your bucket, you must deny them the <code>s3:DeleteObject</code>, <code>s3:DeleteObjectVersion</code>, and <code>s3:PutLifeCycleConfiguration</code> actions. </p> <p>The following action is related to <code>DeleteObject</code>:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html">PutObject</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The bucket name of the bucket containing the object. </p>
 @param key Key name of the object to delete.
 @return ApiDeleteObjectRequest
*/
func (a *ObjectAPIService) DeleteObject(ctx context.Context, bucket string, key string) ApiDeleteObjectRequest {
	return ApiDeleteObjectRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
		key: key,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ObjectAPIService) DeleteObjectExecute(r ApiDeleteObjectRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.DeleteObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}

	if r.versionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionId", r.versionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzMfa != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-mfa", r.xAmzMfa, "")
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	if r.xAmzBypassGovernanceRetention != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-bypass-governance-retention", r.xAmzBypassGovernanceRetention, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetObjectRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	bucket string
	key string
	xAmzSecurityToken *string
	ifMatch *string
	ifModifiedSince *time.Time
	ifNoneMatch *string
	ifUnmodifiedSince *time.Time
	range_ *string
	responseCacheControl *string
	responseContentDisposition *string
	responseContentEncoding *string
	responseContentLanguage *string
	responseContentType *string
	responseExpires *time.Time
	versionId *string
	xAmzServerSideEncryptionCustomerAlgorithm *string
	xAmzServerSideEncryptionCustomerKey *string
	xAmzServerSideEncryptionCustomerKeyMD5 *string
	xAmzRequestPayer *string
	partNumber *int32
	xAmzExpectedBucketOwner *string
}

// This parameter is currently not supported and is not required.
func (r ApiGetObjectRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiGetObjectRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// Return the object only if its entity tag (ETag) is the same as the one specified, otherwise return a 412 (precondition failed).
func (r ApiGetObjectRequest) IfMatch(ifMatch string) ApiGetObjectRequest {
	r.ifMatch = &ifMatch
	return r
}

// Return the object only if it has been modified since the specified time, otherwise return a 304 (not modified).
func (r ApiGetObjectRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetObjectRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Return the object only if its entity tag (ETag) is different from the one specified, otherwise return a 304 (not modified).
func (r ApiGetObjectRequest) IfNoneMatch(ifNoneMatch string) ApiGetObjectRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// Return the object only if it has not been modified since the specified time, otherwise return a 412 (precondition failed).
func (r ApiGetObjectRequest) IfUnmodifiedSince(ifUnmodifiedSince time.Time) ApiGetObjectRequest {
	r.ifUnmodifiedSince = &ifUnmodifiedSince
	return r
}

// &lt;p&gt;Downloads the specified range bytes of an object. For more information about the HTTP Range header, see &lt;a href&#x3D;\&quot;https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35\&quot;&gt;https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35&lt;/a&gt;.&lt;/p&gt; &lt;note&gt; &lt;p&gt;ArvanCloud S3 doesn&#39;t support retrieving multiple ranges of data per &lt;code&gt;GET&lt;/code&gt; request.&lt;/p&gt; &lt;/note&gt;
func (r ApiGetObjectRequest) Range_(range_ string) ApiGetObjectRequest {
	r.range_ = &range_
	return r
}

// Sets the &lt;code&gt;Cache-Control&lt;/code&gt; header of the response.
func (r ApiGetObjectRequest) ResponseCacheControl(responseCacheControl string) ApiGetObjectRequest {
	r.responseCacheControl = &responseCacheControl
	return r
}

// Sets the &lt;code&gt;Content-Disposition&lt;/code&gt; header of the response
func (r ApiGetObjectRequest) ResponseContentDisposition(responseContentDisposition string) ApiGetObjectRequest {
	r.responseContentDisposition = &responseContentDisposition
	return r
}

// Sets the &lt;code&gt;Content-Encoding&lt;/code&gt; header of the response.
func (r ApiGetObjectRequest) ResponseContentEncoding(responseContentEncoding string) ApiGetObjectRequest {
	r.responseContentEncoding = &responseContentEncoding
	return r
}

// Sets the &lt;code&gt;Content-Language&lt;/code&gt; header of the response.
func (r ApiGetObjectRequest) ResponseContentLanguage(responseContentLanguage string) ApiGetObjectRequest {
	r.responseContentLanguage = &responseContentLanguage
	return r
}

// Sets the &lt;code&gt;Content-Type&lt;/code&gt; header of the response.
func (r ApiGetObjectRequest) ResponseContentType(responseContentType string) ApiGetObjectRequest {
	r.responseContentType = &responseContentType
	return r
}

// Sets the &lt;code&gt;Expires&lt;/code&gt; header of the response.
func (r ApiGetObjectRequest) ResponseExpires(responseExpires time.Time) ApiGetObjectRequest {
	r.responseExpires = &responseExpires
	return r
}

// VersionId used to reference a specific version of the object.
func (r ApiGetObjectRequest) VersionId(versionId string) ApiGetObjectRequest {
	r.versionId = &versionId
	return r
}

// Specifies the algorithm to use to when decrypting the object (for example, AES256).
func (r ApiGetObjectRequest) XAmzServerSideEncryptionCustomerAlgorithm(xAmzServerSideEncryptionCustomerAlgorithm string) ApiGetObjectRequest {
	r.xAmzServerSideEncryptionCustomerAlgorithm = &xAmzServerSideEncryptionCustomerAlgorithm
	return r
}

// Specifies the customer-provided encryption key for ArvanCloud S3 used to encrypt the data. This value is used to decrypt the object when recovering it and must match the one used when storing the data. The key must be appropriate for use with the algorithm specified in the &lt;code&gt;x-amz-server-side-encryption-customer-algorithm&lt;/code&gt; header.
func (r ApiGetObjectRequest) XAmzServerSideEncryptionCustomerKey(xAmzServerSideEncryptionCustomerKey string) ApiGetObjectRequest {
	r.xAmzServerSideEncryptionCustomerKey = &xAmzServerSideEncryptionCustomerKey
	return r
}

// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. ArvanCloud S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
func (r ApiGetObjectRequest) XAmzServerSideEncryptionCustomerKeyMD5(xAmzServerSideEncryptionCustomerKeyMD5 string) ApiGetObjectRequest {
	r.xAmzServerSideEncryptionCustomerKeyMD5 = &xAmzServerSideEncryptionCustomerKeyMD5
	return r
}

// 
func (r ApiGetObjectRequest) XAmzRequestPayer(xAmzRequestPayer string) ApiGetObjectRequest {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

// Part number of the object being read. This is a positive integer between 1 and 10,000. Effectively performs a &#39;ranged&#39; GET request for the part specified. Useful for downloading just a part of an object.
func (r ApiGetObjectRequest) PartNumber(partNumber int32) ApiGetObjectRequest {
	r.partNumber = &partNumber
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiGetObjectRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiGetObjectRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiGetObjectRequest) Execute() (*GetObjectOutput, *http.Response, error) {
	return r.ApiService.GetObjectExecute(r)
}

/*
GetObject Method for GetObject

<p>Retrieves objects from ArvanCloud S3. To use <code>GET</code>, you must have <code>READ</code> access to the object. If you grant <code>READ</code> access to the anonymous user, you can return the object without using an authorization header.</p> <p>An ArvanCloud S3 bucket has no directory hierarchy such as you would find in a typical computer file system. You can, however, create a logical hierarchy by using object key names that imply a folder structure. For example, instead of naming an object <code>sample.jpg</code>, you can name it <code>photos/2006/February/sample.jpg</code>.</p> <p>To get an object from such a logical hierarchy, specify the full key name for the object in the <code>GET</code> operation. For a virtual hosted-style request example, if you have the object <code>photos/2006/February/sample.jpg</code>, specify the resource as <code>/photos/2006/February/sample.jpg</code>. For a path-style request example, if you have the object <code>photos/2006/February/sample.jpg</code> in the bucket named <code>examplebucket</code>, specify the resource as <code>/examplebucket/photos/2006/February/sample.jpg</code>. For more information about request types, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/VirtualHosting.html#VirtualHostingSpecifyBucket">HTTP Host Header Bucket Specification</a>.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The bucket name containing the object. </p>
 @param key Key of the object to get.
 @return ApiGetObjectRequest
*/
func (a *ObjectAPIService) GetObject(ctx context.Context, bucket string, key string) ApiGetObjectRequest {
	return ApiGetObjectRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
		key: key,
	}
}

// Execute executes the request
//  @return GetObjectOutput
func (a *ObjectAPIService) GetObjectExecute(r ApiGetObjectRequest) (*GetObjectOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetObjectOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}

	if r.responseCacheControl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response-cache-control", r.responseCacheControl, "")
	}
	if r.responseContentDisposition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response-content-disposition", r.responseContentDisposition, "")
	}
	if r.responseContentEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response-content-encoding", r.responseContentEncoding, "")
	}
	if r.responseContentLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response-content-language", r.responseContentLanguage, "")
	}
	if r.responseContentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response-content-type", r.responseContentType, "")
	}
	if r.responseExpires != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response-expires", r.responseExpires, "")
	}
	if r.versionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionId", r.versionId, "")
	}
	if r.partNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partNumber", r.partNumber, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "")
	}
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "")
	}
	if r.ifUnmodifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Unmodified-Since", r.ifUnmodifiedSince, "")
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	if r.xAmzServerSideEncryptionCustomerAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-algorithm", r.xAmzServerSideEncryptionCustomerAlgorithm, "")
	}
	if r.xAmzServerSideEncryptionCustomerKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key", r.xAmzServerSideEncryptionCustomerKey, "")
	}
	if r.xAmzServerSideEncryptionCustomerKeyMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key-MD5", r.xAmzServerSideEncryptionCustomerKeyMD5, "")
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 480 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 481 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadObjectRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	bucket string
	key string
	xAmzSecurityToken *string
	ifMatch *string
	ifModifiedSince *time.Time
	ifNoneMatch *string
	ifUnmodifiedSince *time.Time
	range_ *string
	versionId *string
	xAmzServerSideEncryptionCustomerAlgorithm *string
	xAmzServerSideEncryptionCustomerKey *string
	xAmzServerSideEncryptionCustomerKeyMD5 *string
	xAmzRequestPayer *string
	partNumber *int32
	xAmzExpectedBucketOwner *string
}

// This parameter is currently not supported and is not required.
func (r ApiHeadObjectRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiHeadObjectRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// Return the object only if its entity tag (ETag) is the same as the one specified, otherwise return a 412 (precondition failed).
func (r ApiHeadObjectRequest) IfMatch(ifMatch string) ApiHeadObjectRequest {
	r.ifMatch = &ifMatch
	return r
}

// Return the object only if it has been modified since the specified time, otherwise return a 304 (not modified).
func (r ApiHeadObjectRequest) IfModifiedSince(ifModifiedSince time.Time) ApiHeadObjectRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Return the object only if its entity tag (ETag) is different from the one specified, otherwise return a 304 (not modified).
func (r ApiHeadObjectRequest) IfNoneMatch(ifNoneMatch string) ApiHeadObjectRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// Return the object only if it has not been modified since the specified time, otherwise return a 412 (precondition failed).
func (r ApiHeadObjectRequest) IfUnmodifiedSince(ifUnmodifiedSince time.Time) ApiHeadObjectRequest {
	r.ifUnmodifiedSince = &ifUnmodifiedSince
	return r
}

// &lt;p&gt;Downloads the specified range bytes of an object. For more information about the HTTP Range header, see &lt;a href&#x3D;\&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35\&quot;&gt;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35&lt;/a&gt;.&lt;/p&gt; &lt;note&gt; &lt;p&gt;ArvanCloud S3 doesn&#39;t support retrieving multiple ranges of data per &lt;code&gt;GET&lt;/code&gt; request.&lt;/p&gt; &lt;/note&gt;
func (r ApiHeadObjectRequest) Range_(range_ string) ApiHeadObjectRequest {
	r.range_ = &range_
	return r
}

// VersionId used to reference a specific version of the object.
func (r ApiHeadObjectRequest) VersionId(versionId string) ApiHeadObjectRequest {
	r.versionId = &versionId
	return r
}

// Specifies the algorithm to use to when encrypting the object (for example, AES256).
func (r ApiHeadObjectRequest) XAmzServerSideEncryptionCustomerAlgorithm(xAmzServerSideEncryptionCustomerAlgorithm string) ApiHeadObjectRequest {
	r.xAmzServerSideEncryptionCustomerAlgorithm = &xAmzServerSideEncryptionCustomerAlgorithm
	return r
}

// Specifies the customer-provided encryption key for ArvanCloud S3 to use in encrypting data. This value is used to store the object and then it is discarded; ArvanCloud S3 does not store the encryption key. The key must be appropriate for use with the algorithm specified in the &lt;code&gt;x-amz-server-side-encryption-customer-algorithm&lt;/code&gt; header.
func (r ApiHeadObjectRequest) XAmzServerSideEncryptionCustomerKey(xAmzServerSideEncryptionCustomerKey string) ApiHeadObjectRequest {
	r.xAmzServerSideEncryptionCustomerKey = &xAmzServerSideEncryptionCustomerKey
	return r
}

// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. ArvanCloud S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
func (r ApiHeadObjectRequest) XAmzServerSideEncryptionCustomerKeyMD5(xAmzServerSideEncryptionCustomerKeyMD5 string) ApiHeadObjectRequest {
	r.xAmzServerSideEncryptionCustomerKeyMD5 = &xAmzServerSideEncryptionCustomerKeyMD5
	return r
}

// 
func (r ApiHeadObjectRequest) XAmzRequestPayer(xAmzRequestPayer string) ApiHeadObjectRequest {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

// Part number of the object being read. This is a positive integer between 1 and 10,000. Effectively performs a &#39;ranged&#39; HEAD request for the part specified. Useful querying about the size of the part and the number of parts in this object.
func (r ApiHeadObjectRequest) PartNumber(partNumber int32) ApiHeadObjectRequest {
	r.partNumber = &partNumber
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiHeadObjectRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiHeadObjectRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiHeadObjectRequest) Execute() (*HeadObjectOutput, *http.Response, error) {
	return r.ApiService.HeadObjectExecute(r)
}

/*
HeadObject Method for HeadObject

<p>The HEAD action retrieves metadata from an object without returning the object itself. This action is useful if you're only interested in an object's metadata. To use HEAD, you must have READ access to the object.</p> <p>A <code>HEAD</code> request has the same options as a <code>GET</code> action on an object. The response is identical to the <code>GET</code> response except that there is no response body. Because of this, if the <code>HEAD</code> request generates an error, it returns a generic <code>404 Not Found</code> or <code>403 Forbidden</code> code. It is not possible to retrieve the exact exception beyond these error codes.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The name of the bucket containing the object.</p>
 @param key The object key.
 @return ApiHeadObjectRequest
*/
func (a *ObjectAPIService) HeadObject(ctx context.Context, bucket string, key string) ApiHeadObjectRequest {
	return ApiHeadObjectRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
		key: key,
	}
}

// Execute executes the request
//  @return HeadObjectOutput
func (a *ObjectAPIService) HeadObjectExecute(r ApiHeadObjectRequest) (*HeadObjectOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HeadObjectOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.HeadObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}

	if r.versionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionId", r.versionId, "")
	}
	if r.partNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partNumber", r.partNumber, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "")
	}
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "")
	}
	if r.ifUnmodifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Unmodified-Since", r.ifUnmodifiedSince, "")
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	if r.xAmzServerSideEncryptionCustomerAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-algorithm", r.xAmzServerSideEncryptionCustomerAlgorithm, "")
	}
	if r.xAmzServerSideEncryptionCustomerKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key", r.xAmzServerSideEncryptionCustomerKey, "")
	}
	if r.xAmzServerSideEncryptionCustomerKeyMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key-MD5", r.xAmzServerSideEncryptionCustomerKeyMD5, "")
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 480 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutObjectRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	bucket string
	key string
	putObjectRequest *PutObjectRequest
	xAmzSecurityToken *string
	xAmzAcl *string
	cacheControl *string
	contentDisposition *string
	contentEncoding *string
	contentLanguage *string
	contentLength *int32
	contentMD5 *string
	contentType *string
	expires *time.Time
	xAmzGrantFullControl *string
	xAmzGrantRead *string
	xAmzGrantReadAcp *string
	xAmzGrantWriteAcp *string
	xAmzServerSideEncryption *string
	xAmzStorageClass *string
	xAmzWebsiteRedirectLocation *string
	xAmzServerSideEncryptionCustomerAlgorithm *string
	xAmzServerSideEncryptionCustomerKey *string
	xAmzServerSideEncryptionCustomerKeyMD5 *string
	xAmzServerSideEncryptionAwsKmsKeyId *string
	xAmzServerSideEncryptionContext *string
	xAmzServerSideEncryptionBucketKeyEnabled *bool
	xAmzRequestPayer *string
	xAmzTagging *string
	xAmzObjectLockMode *string
	xAmzObjectLockRetainUntilDate *time.Time
	xAmzObjectLockLegalHold *string
	xAmzExpectedBucketOwner *string
}

func (r ApiPutObjectRequest) PutObjectRequest(putObjectRequest PutObjectRequest) ApiPutObjectRequest {
	r.putObjectRequest = &putObjectRequest
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiPutObjectRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiPutObjectRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// &lt;p&gt;The canned ACL to apply to the object. For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL\&quot;&gt;Canned ACL&lt;/a&gt;.&lt;/p&gt; &lt;/p&gt;
func (r ApiPutObjectRequest) XAmzAcl(xAmzAcl string) ApiPutObjectRequest {
	r.xAmzAcl = &xAmzAcl
	return r
}

//  Can be used to specify caching behavior along the request/reply chain. For more information, see &lt;a href&#x3D;\&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9\&quot;&gt;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9&lt;/a&gt;.
func (r ApiPutObjectRequest) CacheControl(cacheControl string) ApiPutObjectRequest {
	r.cacheControl = &cacheControl
	return r
}

// Specifies presentational information for the object. For more information, see &lt;a href&#x3D;\&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1\&quot;&gt;http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1&lt;/a&gt;.
func (r ApiPutObjectRequest) ContentDisposition(contentDisposition string) ApiPutObjectRequest {
	r.contentDisposition = &contentDisposition
	return r
}

// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. For more information, see &lt;a href&#x3D;\&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11\&quot;&gt;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11&lt;/a&gt;.
func (r ApiPutObjectRequest) ContentEncoding(contentEncoding string) ApiPutObjectRequest {
	r.contentEncoding = &contentEncoding
	return r
}

// The language the content is in.
func (r ApiPutObjectRequest) ContentLanguage(contentLanguage string) ApiPutObjectRequest {
	r.contentLanguage = &contentLanguage
	return r
}

// Size of the body in bytes. This parameter is useful when the size of the body cannot be determined automatically. For more information, see &lt;a href&#x3D;\&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13\&quot;&gt;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13&lt;/a&gt;.
func (r ApiPutObjectRequest) ContentLength(contentLength int32) ApiPutObjectRequest {
	r.contentLength = &contentLength
	return r
}

// The base64-encoded 128-bit MD5 digest of the message (without the headers) according to RFC 1864. This header can be used as a message integrity check to verify that the data is the same data that was originally sent. Although it is optional, we recommend using the Content-MD5 mechanism as an end-to-end integrity check. For more information about REST request authentication, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html\&quot;&gt;REST Authentication&lt;/a&gt;.
func (r ApiPutObjectRequest) ContentMD5(contentMD5 string) ApiPutObjectRequest {
	r.contentMD5 = &contentMD5
	return r
}

// A standard MIME type describing the format of the contents. For more information, see &lt;a href&#x3D;\&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17\&quot;&gt;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17&lt;/a&gt;.
func (r ApiPutObjectRequest) ContentType(contentType string) ApiPutObjectRequest {
	r.contentType = &contentType
	return r
}

// The date and time at which the object is no longer cacheable. For more information, see &lt;a href&#x3D;\&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21\&quot;&gt;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21&lt;/a&gt;.
func (r ApiPutObjectRequest) Expires(expires time.Time) ApiPutObjectRequest {
	r.expires = &expires
	return r
}

// &lt;p&gt;Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.&lt;/p&gt; &lt;/p&gt;
func (r ApiPutObjectRequest) XAmzGrantFullControl(xAmzGrantFullControl string) ApiPutObjectRequest {
	r.xAmzGrantFullControl = &xAmzGrantFullControl
	return r
}

// &lt;p&gt;Allows grantee to read the object data and its metadata.&lt;/p&gt; &lt;/p&gt;
func (r ApiPutObjectRequest) XAmzGrantRead(xAmzGrantRead string) ApiPutObjectRequest {
	r.xAmzGrantRead = &xAmzGrantRead
	return r
}

// &lt;p&gt;Allows grantee to read the object ACL.&lt;/p&gt; &lt;/p&gt;
func (r ApiPutObjectRequest) XAmzGrantReadAcp(xAmzGrantReadAcp string) ApiPutObjectRequest {
	r.xAmzGrantReadAcp = &xAmzGrantReadAcp
	return r
}

// &lt;p&gt;Allows grantee to write the ACL for the applicable object.&lt;/p&gt; &lt;/p&gt;
func (r ApiPutObjectRequest) XAmzGrantWriteAcp(xAmzGrantWriteAcp string) ApiPutObjectRequest {
	r.xAmzGrantWriteAcp = &xAmzGrantWriteAcp
	return r
}

// The server-side encryption algorithm used when storing this object in ArvanCloud S3 (for example, AES256, aws:kms).
func (r ApiPutObjectRequest) XAmzServerSideEncryption(xAmzServerSideEncryption string) ApiPutObjectRequest {
	r.xAmzServerSideEncryption = &xAmzServerSideEncryption
	return r
}

// By default, ArvanCloud S3 uses the STANDARD Storage Class to store newly created objects. The STANDARD storage class provides high durability and high availability. Depending on performance needs, you can specify a different Storage Class.
func (r ApiPutObjectRequest) XAmzStorageClass(xAmzStorageClass string) ApiPutObjectRequest {
	r.xAmzStorageClass = &xAmzStorageClass
	return r
}

// &lt;p&gt;If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. ArvanCloud S3 stores the value of this header in the object metadata. For information about object metadata, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html\&quot;&gt;Object Key and Metadata&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;In the following example, the request header sets the redirect to an object (anotherPage.html) in the same bucket:&lt;/p&gt; &lt;p&gt; &lt;code&gt;x-amz-website-redirect-location: /anotherPage.html&lt;/code&gt; &lt;/p&gt; &lt;p&gt;In the following example, the request header sets the object redirect to another website:&lt;/p&gt; &lt;p&gt; &lt;code&gt;x-amz-website-redirect-location: http://www.example.com/&lt;/code&gt; &lt;/p&gt; &lt;/p&gt;
func (r ApiPutObjectRequest) XAmzWebsiteRedirectLocation(xAmzWebsiteRedirectLocation string) ApiPutObjectRequest {
	r.xAmzWebsiteRedirectLocation = &xAmzWebsiteRedirectLocation
	return r
}

// Specifies the algorithm to use to when encrypting the object (for example, AES256).
func (r ApiPutObjectRequest) XAmzServerSideEncryptionCustomerAlgorithm(xAmzServerSideEncryptionCustomerAlgorithm string) ApiPutObjectRequest {
	r.xAmzServerSideEncryptionCustomerAlgorithm = &xAmzServerSideEncryptionCustomerAlgorithm
	return r
}

// Specifies the customer-provided encryption key for ArvanCloud S3 to use in encrypting data. This value is used to store the object and then it is discarded; ArvanCloud S3 does not store the encryption key. The key must be appropriate for use with the algorithm specified in the &lt;code&gt;x-amz-server-side-encryption-customer-algorithm&lt;/code&gt; header.
func (r ApiPutObjectRequest) XAmzServerSideEncryptionCustomerKey(xAmzServerSideEncryptionCustomerKey string) ApiPutObjectRequest {
	r.xAmzServerSideEncryptionCustomerKey = &xAmzServerSideEncryptionCustomerKey
	return r
}

// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. ArvanCloud S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
func (r ApiPutObjectRequest) XAmzServerSideEncryptionCustomerKeyMD5(xAmzServerSideEncryptionCustomerKeyMD5 string) ApiPutObjectRequest {
	r.xAmzServerSideEncryptionCustomerKeyMD5 = &xAmzServerSideEncryptionCustomerKeyMD5
	return r
}

// If &lt;code&gt;x-amz-server-side-encryption&lt;/code&gt; is present and has the value of &lt;code&gt;aws:kms&lt;/code&gt;, this header specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetrical customer managed key that was used for the object. If you specify &lt;code&gt;x-amz-server-side-encryption:aws:kms&lt;/code&gt;, but do not provide&lt;code&gt; x-amz-server-side-encryption-aws-kms-key-id&lt;/code&gt;, ArvanCloud S3 uses the Amazon Web Services managed key to protect the data. If the KMS key does not exist in the same account issuing the command, you must use the full ARN and not just the ID. 
func (r ApiPutObjectRequest) XAmzServerSideEncryptionAwsKmsKeyId(xAmzServerSideEncryptionAwsKmsKeyId string) ApiPutObjectRequest {
	r.xAmzServerSideEncryptionAwsKmsKeyId = &xAmzServerSideEncryptionAwsKmsKeyId
	return r
}

// Specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
func (r ApiPutObjectRequest) XAmzServerSideEncryptionContext(xAmzServerSideEncryptionContext string) ApiPutObjectRequest {
	r.xAmzServerSideEncryptionContext = &xAmzServerSideEncryptionContext
	return r
}

// &lt;p&gt;Specifies whether ArvanCloud S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to &lt;code&gt;true&lt;/code&gt; causes ArvanCloud S3 to use an S3 Bucket Key for object encryption with SSE-KMS.&lt;/p&gt; &lt;p&gt;Specifying this header with a PUT action doesn’t affect bucket-level settings for S3 Bucket Key.&lt;/p&gt;
func (r ApiPutObjectRequest) XAmzServerSideEncryptionBucketKeyEnabled(xAmzServerSideEncryptionBucketKeyEnabled bool) ApiPutObjectRequest {
	r.xAmzServerSideEncryptionBucketKeyEnabled = &xAmzServerSideEncryptionBucketKeyEnabled
	return r
}

// 
func (r ApiPutObjectRequest) XAmzRequestPayer(xAmzRequestPayer string) ApiPutObjectRequest {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

// The tag-set for the object. The tag-set must be encoded as URL Query parameters. (For example, \&quot;Key1&#x3D;Value1\&quot;)
func (r ApiPutObjectRequest) XAmzTagging(xAmzTagging string) ApiPutObjectRequest {
	r.xAmzTagging = &xAmzTagging
	return r
}

// The Object Lock mode that you want to apply to this object.
func (r ApiPutObjectRequest) XAmzObjectLockMode(xAmzObjectLockMode string) ApiPutObjectRequest {
	r.xAmzObjectLockMode = &xAmzObjectLockMode
	return r
}

// The date and time when you want this object&#39;s Object Lock to expire. Must be formatted as a timestamp parameter.
func (r ApiPutObjectRequest) XAmzObjectLockRetainUntilDate(xAmzObjectLockRetainUntilDate time.Time) ApiPutObjectRequest {
	r.xAmzObjectLockRetainUntilDate = &xAmzObjectLockRetainUntilDate
	return r
}

// Specifies whether a legal hold will be applied to this object. For more information about S3 Object Lock, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html\&quot;&gt;Object Lock&lt;/a&gt;.
func (r ApiPutObjectRequest) XAmzObjectLockLegalHold(xAmzObjectLockLegalHold string) ApiPutObjectRequest {
	r.xAmzObjectLockLegalHold = &xAmzObjectLockLegalHold
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiPutObjectRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiPutObjectRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiPutObjectRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PutObjectExecute(r)
}

/*
PutObject Method for PutObject

<p>Adds an object to a bucket. You must have WRITE permissions on a bucket to add an object to it.</p> <p>ArvanCloud S3 never adds partial objects; if you receive a success response, ArvanCloud S3 added the entire object to the bucket.</p> <p>ArvanCloud S3 is a distributed system. If it receives multiple write requests for the same object simultaneously, it overwrites all but the last object written. ArvanCloud S3 does not provide object locking; if you need this, make sure to build it into your application layer or use versioning instead.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The bucket name to which the PUT action was initiated. </p> <p>
 @param key Object key for which the PUT action was initiated.
 @return ApiPutObjectRequest
*/
func (a *ObjectAPIService) PutObject(ctx context.Context, bucket string, key string) ApiPutObjectRequest {
	return ApiPutObjectRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
		key: key,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ObjectAPIService) PutObjectExecute(r ApiPutObjectRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.PutObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.putObjectRequest == nil {
		return localVarReturnValue, nil, reportError("putObjectRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzAcl != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-acl", r.xAmzAcl, "")
	}
	if r.cacheControl != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Cache-Control", r.cacheControl, "")
	}
	if r.contentDisposition != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Disposition", r.contentDisposition, "")
	}
	if r.contentEncoding != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Encoding", r.contentEncoding, "")
	}
	if r.contentLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Language", r.contentLanguage, "")
	}
	if r.contentLength != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Length", r.contentLength, "")
	}
	if r.contentMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-MD5", r.contentMD5, "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
	}
	if r.expires != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Expires", r.expires, "")
	}
	if r.xAmzGrantFullControl != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-grant-full-control", r.xAmzGrantFullControl, "")
	}
	if r.xAmzGrantRead != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-grant-read", r.xAmzGrantRead, "")
	}
	if r.xAmzGrantReadAcp != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-grant-read-acp", r.xAmzGrantReadAcp, "")
	}
	if r.xAmzGrantWriteAcp != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-grant-write-acp", r.xAmzGrantWriteAcp, "")
	}
	if r.xAmzServerSideEncryption != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption", r.xAmzServerSideEncryption, "")
	}
	if r.xAmzStorageClass != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-storage-class", r.xAmzStorageClass, "")
	}
	if r.xAmzWebsiteRedirectLocation != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-website-redirect-location", r.xAmzWebsiteRedirectLocation, "")
	}
	if r.xAmzServerSideEncryptionCustomerAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-algorithm", r.xAmzServerSideEncryptionCustomerAlgorithm, "")
	}
	if r.xAmzServerSideEncryptionCustomerKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key", r.xAmzServerSideEncryptionCustomerKey, "")
	}
	if r.xAmzServerSideEncryptionCustomerKeyMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key-MD5", r.xAmzServerSideEncryptionCustomerKeyMD5, "")
	}
	if r.xAmzServerSideEncryptionAwsKmsKeyId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-aws-kms-key-id", r.xAmzServerSideEncryptionAwsKmsKeyId, "")
	}
	if r.xAmzServerSideEncryptionContext != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-context", r.xAmzServerSideEncryptionContext, "")
	}
	if r.xAmzServerSideEncryptionBucketKeyEnabled != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-bucket-key-enabled", r.xAmzServerSideEncryptionBucketKeyEnabled, "")
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	if r.xAmzTagging != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-tagging", r.xAmzTagging, "")
	}
	if r.xAmzObjectLockMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-object-lock-mode", r.xAmzObjectLockMode, "")
	}
	if r.xAmzObjectLockRetainUntilDate != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-object-lock-retain-until-date", r.xAmzObjectLockRetainUntilDate, "")
	}
	if r.xAmzObjectLockLegalHold != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-object-lock-legal-hold", r.xAmzObjectLockLegalHold, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	// body params
	localVarPostBody = r.putObjectRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
