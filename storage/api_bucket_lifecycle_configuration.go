/*
ArvanCloud S3 Services

<p/>

API version: 2006-03-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package storage

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BucketLifecycleConfigurationAPIService BucketLifecycleConfigurationAPI service
type BucketLifecycleConfigurationAPIService service

type ApiDeleteBucketLifecycleRequest struct {
	ctx context.Context
	ApiService *BucketLifecycleConfigurationAPIService
	bucket string
	lifecycle *bool
	xAmzSecurityToken *string
	xAmzExpectedBucketOwner *string
}

func (r ApiDeleteBucketLifecycleRequest) Lifecycle(lifecycle bool) ApiDeleteBucketLifecycleRequest {
	r.lifecycle = &lifecycle
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiDeleteBucketLifecycleRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiDeleteBucketLifecycleRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiDeleteBucketLifecycleRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiDeleteBucketLifecycleRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiDeleteBucketLifecycleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBucketLifecycleExecute(r)
}

/*
DeleteBucketLifecycle Method for DeleteBucketLifecycle

<p>Deletes the lifecycle configuration from the specified bucket. ArvanCloud S3 removes all the lifecycle configuration rules in the lifecycle subresource associated with the bucket. Your objects never expire, and ArvanCloud S3 no longer automatically deletes any objects on the basis of rules contained in the deleted lifecycle configuration.</p> <p>To use this operation, you must have permission to perform the <code>s3:PutLifecycleConfiguration</code> action. By default, the bucket owner has this permission and the bucket owner can grant this permission to others.</p> <p>There is usually some time lag before lifecycle configuration deletion is fully propagated to all the ArvanCloud S3 systems.</p> <p>For more information about the object expiration, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#intro-lifecycle-rules-actions">Elements to Describe Lifecycle Actions</a>.</p> <p>Related actions include:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketLifecycleConfiguration.html">PutBucketLifecycleConfiguration</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetBucketLifecycleConfiguration.html">GetBucketLifecycleConfiguration</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket The bucket name of the lifecycle to delete.
 @return ApiDeleteBucketLifecycleRequest
*/
func (a *BucketLifecycleConfigurationAPIService) DeleteBucketLifecycle(ctx context.Context, bucket string) ApiDeleteBucketLifecycleRequest {
	return ApiDeleteBucketLifecycleRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
func (a *BucketLifecycleConfigurationAPIService) DeleteBucketLifecycleExecute(r ApiDeleteBucketLifecycleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketLifecycleConfigurationAPIService.DeleteBucketLifecycle")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}#lifecycle"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lifecycle == nil {
		return nil, reportError("lifecycle is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "lifecycle", r.lifecycle, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBucketLifecycleConfigurationRequest struct {
	ctx context.Context
	ApiService *BucketLifecycleConfigurationAPIService
	bucket string
	lifecycle *bool
	xAmzSecurityToken *string
	xAmzExpectedBucketOwner *string
}

func (r ApiGetBucketLifecycleConfigurationRequest) Lifecycle(lifecycle bool) ApiGetBucketLifecycleConfigurationRequest {
	r.lifecycle = &lifecycle
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiGetBucketLifecycleConfigurationRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiGetBucketLifecycleConfigurationRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiGetBucketLifecycleConfigurationRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiGetBucketLifecycleConfigurationRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiGetBucketLifecycleConfigurationRequest) Execute() (*GetBucketLifecycleConfigurationOutput, *http.Response, error) {
	return r.ApiService.GetBucketLifecycleConfigurationExecute(r)
}

/*
GetBucketLifecycleConfiguration Method for GetBucketLifecycleConfiguration

<note> <p>Bucket lifecycle configuration now supports specifying a lifecycle rule using an object key name prefix, one or more object tags, or a combination of both. Accordingly, this section describes the latest API. The response describes the new filter element that you can use to specify a filter to select a subset of objects to which the rule applies. If you are using a previous version of the lifecycle configuration, it still works. For the earlier action, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetBucketLifecycle.html">GetBucketLifecycle</a>.</p> </note> <p>Returns the lifecycle configuration information set on the bucket. For information about lifecycle configuration, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html">Object Lifecycle Management</a>.</p> <p>To use this operation, you must have permission to perform the <code>s3:GetLifecycleConfiguration</code> action.<p> <code>GetBucketLifecycleConfiguration</code> has the following special error:</p> <ul> <li> <p>Error code: <code>NoSuchLifecycleConfiguration</code> </p> <ul> <li> <p>Description: The lifecycle configuration does not exist.</p> </li> <li> <p>HTTP Status Code: 404 Not Found</p> </li> <li> <p>SOAP Fault Code Prefix: Client</p> </li> </ul> </li> </ul> <p>The following operations are related to <code>GetBucketLifecycleConfiguration</code>:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetBucketLifecycle.html">GetBucketLifecycle</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketLifecycle.html">PutBucketLifecycle</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_DeleteBucketLifecycle.html">DeleteBucketLifecycle</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket The name of the bucket for which to get the lifecycle information.
 @return ApiGetBucketLifecycleConfigurationRequest
*/
func (a *BucketLifecycleConfigurationAPIService) GetBucketLifecycleConfiguration(ctx context.Context, bucket string) ApiGetBucketLifecycleConfigurationRequest {
	return ApiGetBucketLifecycleConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
//  @return GetBucketLifecycleConfigurationOutput
func (a *BucketLifecycleConfigurationAPIService) GetBucketLifecycleConfigurationExecute(r ApiGetBucketLifecycleConfigurationRequest) (*GetBucketLifecycleConfigurationOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBucketLifecycleConfigurationOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketLifecycleConfigurationAPIService.GetBucketLifecycleConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}#lifecycle"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lifecycle == nil {
		return localVarReturnValue, nil, reportError("lifecycle is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "lifecycle", r.lifecycle, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutBucketLifecycleConfigurationRequest struct {
	ctx context.Context
	ApiService *BucketLifecycleConfigurationAPIService
	bucket string
	lifecycle *bool
	putBucketLifecycleConfigurationRequest *PutBucketLifecycleConfigurationRequest
	xAmzSecurityToken *string
	xAmzExpectedBucketOwner *string
}

func (r ApiPutBucketLifecycleConfigurationRequest) Lifecycle(lifecycle bool) ApiPutBucketLifecycleConfigurationRequest {
	r.lifecycle = &lifecycle
	return r
}

func (r ApiPutBucketLifecycleConfigurationRequest) PutBucketLifecycleConfigurationRequest(putBucketLifecycleConfigurationRequest PutBucketLifecycleConfigurationRequest) ApiPutBucketLifecycleConfigurationRequest {
	r.putBucketLifecycleConfigurationRequest = &putBucketLifecycleConfigurationRequest
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiPutBucketLifecycleConfigurationRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiPutBucketLifecycleConfigurationRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiPutBucketLifecycleConfigurationRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiPutBucketLifecycleConfigurationRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiPutBucketLifecycleConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutBucketLifecycleConfigurationExecute(r)
}

/*
PutBucketLifecycleConfiguration Method for PutBucketLifecycleConfiguration

<p>Creates a new lifecycle configuration for the bucket or replaces an existing lifecycle configuration. For information about lifecycle configuration, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lifecycle-mgmt.html">Managing your storage lifecycle</a>.</p> <note> <p>Bucket lifecycle configuration now supports specifying a lifecycle rule using an object key name prefix, one or more object tags, or a combination of both. Accordingly, this section describes the latest API. The previous version of the API supported filtering based only on an object key name prefix, which is supported for backward compatibility. For the related API description, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketLifecycle.html">PutBucketLifecycle</a>.</p> </note> <p> <b>Rules</b> </p> <p>You specify the lifecycle configuration in your request body. The lifecycle configuration is specified as XML consisting of one or more rules. Each rule consists of the following:</p> <ul> <li> <p>Filter identifying a subset of objects to which the rule applies. The filter can be based on a key name prefix, object tags, or a combination of both.</p> </li> <li> <p>Status whether the rule is in effect.</p> </li> <li> <p>One or more lifecycle transition and expiration actions that you want ArvanCloud S3 to perform on the objects identified by the filter. If the state of your bucket is versioning-enabled or versioning-suspended, you can have many versions of the same object (one current version and zero or more noncurrent versions). ArvanCloud S3 provides predefined actions that you can specify for current and noncurrent object versions.</p> </li> </ul> <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html">Object Lifecycle Management</a> and <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html">Lifecycle Configuration Elements</a>.</p> <p> <b>Permissions</b> </p> <p>By default, all ArvanCloud S3 resources are private, including buckets, objects, and related subresources (for example, lifecycle configuration and website configuration). Only the resource owner (that is, the Amazon Web Services account that created it) can access the resource. The resource owner can optionally grant access permissions to others by writing an access policy. For this operation, a user must get the s3:PutLifecycleConfiguration permission.</p> <p>You can also explicitly deny permissions. Explicit deny also supersedes any other permissions. If you want to block users or accounts from removing or deleting objects from your bucket, you must deny them permissions for the following actions:</p> <ul> <li> <p>s3:DeleteObject</p> </li> <li> <p>s3:DeleteObjectVersion</p> </li> <li> <p>s3:PutLifecycleConfiguration</p> </li> </ul> <p>For more information about permissions, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-access-control.html">Managing Access Permissions to Your ArvanCloud S3 Resources</a>.</p> <p>The following are related to <code>PutBucketLifecycleConfiguration</code>:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-configuration-examples.html">Examples of Lifecycle Configuration</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetBucketLifecycleConfiguration.html">GetBucketLifecycleConfiguration</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_DeleteBucketLifecycle.html">DeleteBucketLifecycle</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket The name of the bucket for which to set the configuration.
 @return ApiPutBucketLifecycleConfigurationRequest
*/
func (a *BucketLifecycleConfigurationAPIService) PutBucketLifecycleConfiguration(ctx context.Context, bucket string) ApiPutBucketLifecycleConfigurationRequest {
	return ApiPutBucketLifecycleConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
func (a *BucketLifecycleConfigurationAPIService) PutBucketLifecycleConfigurationExecute(r ApiPutBucketLifecycleConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketLifecycleConfigurationAPIService.PutBucketLifecycleConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}#lifecycle"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lifecycle == nil {
		return nil, reportError("lifecycle is required and must be specified")
	}
	if r.putBucketLifecycleConfigurationRequest == nil {
		return nil, reportError("putBucketLifecycleConfigurationRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "lifecycle", r.lifecycle, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	// body params
	localVarPostBody = r.putBucketLifecycleConfigurationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
