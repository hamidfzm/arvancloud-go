/*
ArvanCloud S3 Services

<p/>

API version: 2006-03-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package storage

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BucketAPIService BucketAPI service
type BucketAPIService service

type ApiCreateBucketRequest struct {
	ctx context.Context
	ApiService *BucketAPIService
	bucket string
	createBucketRequest *CreateBucketRequest
	xAmzSecurityToken *string
	xAmzAcl *string
	xAmzGrantFullControl *string
	xAmzGrantRead *string
	xAmzGrantReadAcp *string
	xAmzGrantWrite *string
	xAmzGrantWriteAcp *string
	xAmzBucketObjectLockEnabled *bool
}

func (r ApiCreateBucketRequest) CreateBucketRequest(createBucketRequest CreateBucketRequest) ApiCreateBucketRequest {
	r.createBucketRequest = &createBucketRequest
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiCreateBucketRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiCreateBucketRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// The canned ACL to apply to the bucket.
func (r ApiCreateBucketRequest) XAmzAcl(xAmzAcl string) ApiCreateBucketRequest {
	r.xAmzAcl = &xAmzAcl
	return r
}

// Allows grantee the read, write, read ACP, and write ACP permissions on the bucket.
func (r ApiCreateBucketRequest) XAmzGrantFullControl(xAmzGrantFullControl string) ApiCreateBucketRequest {
	r.xAmzGrantFullControl = &xAmzGrantFullControl
	return r
}

// Allows grantee to list the objects in the bucket.
func (r ApiCreateBucketRequest) XAmzGrantRead(xAmzGrantRead string) ApiCreateBucketRequest {
	r.xAmzGrantRead = &xAmzGrantRead
	return r
}

// Allows grantee to read the bucket ACL.
func (r ApiCreateBucketRequest) XAmzGrantReadAcp(xAmzGrantReadAcp string) ApiCreateBucketRequest {
	r.xAmzGrantReadAcp = &xAmzGrantReadAcp
	return r
}

// &lt;p&gt;Allows grantee to create new objects in the bucket.&lt;/p&gt; &lt;p&gt;For the bucket and object owners of existing objects, also allows deletions and overwrites of those objects.&lt;/p&gt;
func (r ApiCreateBucketRequest) XAmzGrantWrite(xAmzGrantWrite string) ApiCreateBucketRequest {
	r.xAmzGrantWrite = &xAmzGrantWrite
	return r
}

// Allows grantee to write the ACL for the applicable bucket.
func (r ApiCreateBucketRequest) XAmzGrantWriteAcp(xAmzGrantWriteAcp string) ApiCreateBucketRequest {
	r.xAmzGrantWriteAcp = &xAmzGrantWriteAcp
	return r
}

// Specifies whether you want S3 Object Lock to be enabled for the new bucket.
func (r ApiCreateBucketRequest) XAmzBucketObjectLockEnabled(xAmzBucketObjectLockEnabled bool) ApiCreateBucketRequest {
	r.xAmzBucketObjectLockEnabled = &xAmzBucketObjectLockEnabled
	return r
}

func (r ApiCreateBucketRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateBucketExecute(r)
}

/*
CreateBucket Method for CreateBucket

<p>Creates a new S3 bucket. To create a bucket, you must register with ArvanCloud S3 and have a valid  Access Key ID to authenticate requests. Anonymous requests are never allowed to create buckets. By creating the bucket, you become the bucket owner.</p> <p>Not every string is an acceptable bucket name. For information about bucket naming restrictions, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html">Bucket naming rules</a>.</p> <p>If you want to create an ArvanCloud S3 bucket, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_CreateBucket.html">Create Bucket</a>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket The name of the bucket to create.
 @return ApiCreateBucketRequest
*/
func (a *BucketAPIService) CreateBucket(ctx context.Context, bucket string) ApiCreateBucketRequest {
	return ApiCreateBucketRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BucketAPIService) CreateBucketExecute(r ApiCreateBucketRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketAPIService.CreateBucket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createBucketRequest == nil {
		return localVarReturnValue, nil, reportError("createBucketRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzAcl != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-acl", r.xAmzAcl, "")
	}
	if r.xAmzGrantFullControl != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-grant-full-control", r.xAmzGrantFullControl, "")
	}
	if r.xAmzGrantRead != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-grant-read", r.xAmzGrantRead, "")
	}
	if r.xAmzGrantReadAcp != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-grant-read-acp", r.xAmzGrantReadAcp, "")
	}
	if r.xAmzGrantWrite != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-grant-write", r.xAmzGrantWrite, "")
	}
	if r.xAmzGrantWriteAcp != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-grant-write-acp", r.xAmzGrantWriteAcp, "")
	}
	if r.xAmzBucketObjectLockEnabled != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-bucket-object-lock-enabled", r.xAmzBucketObjectLockEnabled, "")
	}
	// body params
	localVarPostBody = r.createBucketRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 480 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 481 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBucketRequest struct {
	ctx context.Context
	ApiService *BucketAPIService
	bucket string
	xAmzSecurityToken *string
	xAmzExpectedBucketOwner *string
}

// This parameter is currently not supported and is not required.
func (r ApiDeleteBucketRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiDeleteBucketRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiDeleteBucketRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiDeleteBucketRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiDeleteBucketRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBucketExecute(r)
}

/*
DeleteBucket Method for DeleteBucket

<p>Deletes the S3 bucket. All objects (including all object versions and delete markers) in the bucket must be deleted before the bucket itself can be deleted.</p> <p class="title"> <b>Related Resources</b> </p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateBucket.html">CreateBucket</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_DeleteObject.html">DeleteObject</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket Specifies the bucket being deleted.
 @return ApiDeleteBucketRequest
*/
func (a *BucketAPIService) DeleteBucket(ctx context.Context, bucket string) ApiDeleteBucketRequest {
	return ApiDeleteBucketRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
func (a *BucketAPIService) DeleteBucketExecute(r ApiDeleteBucketRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketAPIService.DeleteBucket")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteObjectsRequest struct {
	ctx context.Context
	ApiService *BucketAPIService
	bucket string
	delete *bool
	deleteObjectsRequest *DeleteObjectsRequest
	xAmzSecurityToken *string
	xAmzMfa *string
	xAmzRequestPayer *string
	xAmzBypassGovernanceRetention *bool
	xAmzExpectedBucketOwner *string
}

func (r ApiDeleteObjectsRequest) Delete(delete bool) ApiDeleteObjectsRequest {
	r.delete = &delete
	return r
}

func (r ApiDeleteObjectsRequest) DeleteObjectsRequest(deleteObjectsRequest DeleteObjectsRequest) ApiDeleteObjectsRequest {
	r.deleteObjectsRequest = &deleteObjectsRequest
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiDeleteObjectsRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiDeleteObjectsRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// The concatenation of the authentication device&#39;s serial number, a space, and the value that is displayed on your authentication device. Required to permanently delete a versioned object if versioning is configured with MFA delete enabled.
func (r ApiDeleteObjectsRequest) XAmzMfa(xAmzMfa string) ApiDeleteObjectsRequest {
	r.xAmzMfa = &xAmzMfa
	return r
}

// 
func (r ApiDeleteObjectsRequest) XAmzRequestPayer(xAmzRequestPayer string) ApiDeleteObjectsRequest {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

// Specifies whether you want to delete this object even if it has a Governance-type Object Lock in place. To use this header, you must have the &lt;code&gt;s3:PutBucketPublicAccessBlock&lt;/code&gt; permission.
func (r ApiDeleteObjectsRequest) XAmzBypassGovernanceRetention(xAmzBypassGovernanceRetention bool) ApiDeleteObjectsRequest {
	r.xAmzBypassGovernanceRetention = &xAmzBypassGovernanceRetention
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiDeleteObjectsRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiDeleteObjectsRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiDeleteObjectsRequest) Execute() (*DeleteObjectsOutput, *http.Response, error) {
	return r.ApiService.DeleteObjectsExecute(r)
}

/*
DeleteObjects Method for DeleteObjects

<p>This action enables you to delete multiple objects from a bucket using a single HTTP request. If you know the object keys that you want to delete, then this action provides a suitable alternative to sending individual delete requests, reducing per-request overhead.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The bucket name containing the objects to delete. </p>
 @return ApiDeleteObjectsRequest
*/
func (a *BucketAPIService) DeleteObjects(ctx context.Context, bucket string) ApiDeleteObjectsRequest {
	return ApiDeleteObjectsRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
//  @return DeleteObjectsOutput
func (a *BucketAPIService) DeleteObjectsExecute(r ApiDeleteObjectsRequest) (*DeleteObjectsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteObjectsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketAPIService.DeleteObjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}#delete"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.delete == nil {
		return localVarReturnValue, nil, reportError("delete is required and must be specified")
	}
	if r.deleteObjectsRequest == nil {
		return localVarReturnValue, nil, reportError("deleteObjectsRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "delete", r.delete, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzMfa != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-mfa", r.xAmzMfa, "")
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	if r.xAmzBypassGovernanceRetention != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-bypass-governance-retention", r.xAmzBypassGovernanceRetention, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	// body params
	localVarPostBody = r.deleteObjectsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePublicAccessBlockRequest struct {
	ctx context.Context
	ApiService *BucketAPIService
	bucket string
	publicAccessBlock *bool
	xAmzSecurityToken *string
	xAmzExpectedBucketOwner *string
}

func (r ApiDeletePublicAccessBlockRequest) PublicAccessBlock(publicAccessBlock bool) ApiDeletePublicAccessBlockRequest {
	r.publicAccessBlock = &publicAccessBlock
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiDeletePublicAccessBlockRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiDeletePublicAccessBlockRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiDeletePublicAccessBlockRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiDeletePublicAccessBlockRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiDeletePublicAccessBlockRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePublicAccessBlockExecute(r)
}

/*
DeletePublicAccessBlock Method for DeletePublicAccessBlock

<p>Removes the <code>PublicAccessBlock</code> configuration for an ArvanCloud S3 bucket. To use this operation, you must have the <code>s3:PutBucketPublicAccessBlock</code> permission. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket the ArvanCloud S3 bucket whose <code>PublicAccessBlock</code> configuration you want to delete. 
 @return ApiDeletePublicAccessBlockRequest
*/
func (a *BucketAPIService) DeletePublicAccessBlock(ctx context.Context, bucket string) ApiDeletePublicAccessBlockRequest {
	return ApiDeletePublicAccessBlockRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
func (a *BucketAPIService) DeletePublicAccessBlockExecute(r ApiDeletePublicAccessBlockRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketAPIService.DeletePublicAccessBlock")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}#publicAccessBlock"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.publicAccessBlock == nil {
		return nil, reportError("publicAccessBlock is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "publicAccessBlock", r.publicAccessBlock, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPublicAccessBlockRequest struct {
	ctx context.Context
	ApiService *BucketAPIService
	bucket string
	publicAccessBlock *bool
	xAmzSecurityToken *string
	xAmzExpectedBucketOwner *string
}

func (r ApiGetPublicAccessBlockRequest) PublicAccessBlock(publicAccessBlock bool) ApiGetPublicAccessBlockRequest {
	r.publicAccessBlock = &publicAccessBlock
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiGetPublicAccessBlockRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiGetPublicAccessBlockRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiGetPublicAccessBlockRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiGetPublicAccessBlockRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiGetPublicAccessBlockRequest) Execute() (*GetPublicAccessBlockOutput, *http.Response, error) {
	return r.ApiService.GetPublicAccessBlockExecute(r)
}

/*
GetPublicAccessBlock Method for GetPublicAccessBlock

<p>Retrieves the <code>PublicAccessBlock</code> configuration for an ArvanCloud S3 bucket. To use this operation, you must have the <code>s3:GetBucketPublicAccessBlock</code> permission. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket The name of the ArvanCloud S3 bucket whose <code>PublicAccessBlock</code> configuration you want to retrieve. 
 @return ApiGetPublicAccessBlockRequest
*/
func (a *BucketAPIService) GetPublicAccessBlock(ctx context.Context, bucket string) ApiGetPublicAccessBlockRequest {
	return ApiGetPublicAccessBlockRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
//  @return GetPublicAccessBlockOutput
func (a *BucketAPIService) GetPublicAccessBlockExecute(r ApiGetPublicAccessBlockRequest) (*GetPublicAccessBlockOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicAccessBlockOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketAPIService.GetPublicAccessBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}#publicAccessBlock"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.publicAccessBlock == nil {
		return localVarReturnValue, nil, reportError("publicAccessBlock is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "publicAccessBlock", r.publicAccessBlock, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadBucketRequest struct {
	ctx context.Context
	ApiService *BucketAPIService
	bucket string
	xAmzSecurityToken *string
	xAmzExpectedBucketOwner *string
}

// This parameter is currently not supported and is not required.
func (r ApiHeadBucketRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiHeadBucketRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiHeadBucketRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiHeadBucketRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiHeadBucketRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadBucketExecute(r)
}

/*
HeadBucket Method for HeadBucket

<p>This action is useful to determine if a bucket exists and you have permission to access it. The action returns a <code>200 OK</code> if the bucket exists and you have permission to access it.</p> <p>If the bucket does not exist or you do not have permission to access it, the <code>HEAD</code> request returns a generic <code>404 Not Found</code> or <code>403 Forbidden</code> code. A message body is not included, so you cannot determine the exception beyond these error codes.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The bucket name.</p>
 @return ApiHeadBucketRequest
*/
func (a *BucketAPIService) HeadBucket(ctx context.Context, bucket string) ApiHeadBucketRequest {
	return ApiHeadBucketRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
func (a *BucketAPIService) HeadBucketExecute(r ApiHeadBucketRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketAPIService.HeadBucket")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 480 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListBucketsRequest struct {
	ctx context.Context
	ApiService *BucketAPIService
	xAmzSecurityToken *string
}

// This parameter is currently not supported and is not required.
func (r ApiListBucketsRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiListBucketsRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

func (r ApiListBucketsRequest) Execute() (*ListBucketsOutput, *http.Response, error) {
	return r.ApiService.ListBucketsExecute(r)
}

/*
ListBuckets Method for ListBuckets

Returns a list of all buckets owned by the authenticated sender of the request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBucketsRequest
*/
func (a *BucketAPIService) ListBuckets(ctx context.Context) ApiListBucketsRequest {
	return ApiListBucketsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListBucketsOutput
func (a *BucketAPIService) ListBucketsExecute(r ApiListBucketsRequest) (*ListBucketsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListBucketsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketAPIService.ListBuckets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListObjectVersionsRequest struct {
	ctx context.Context
	ApiService *BucketAPIService
	bucket string
	versions *bool
	xAmzSecurityToken *string
	delimiter *string
	encodingType *string
	keyMarker *string
	maxKeys *int32
	prefix *string
	versionIdMarker *string
	xAmzExpectedBucketOwner *string
	maxKeys2 *string
	keyMarker2 *string
	versionIdMarker2 *string
}

func (r ApiListObjectVersionsRequest) Versions(versions bool) ApiListObjectVersionsRequest {
	r.versions = &versions
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiListObjectVersionsRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiListObjectVersionsRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// A delimiter is a character that you specify to group keys. All keys that contain the same string between the &lt;code&gt;prefix&lt;/code&gt; and the first occurrence of the delimiter are grouped under a single result element in CommonPrefixes. These groups are counted as one result against the max-keys limitation. These keys are not returned elsewhere in the response.
func (r ApiListObjectVersionsRequest) Delimiter(delimiter string) ApiListObjectVersionsRequest {
	r.delimiter = &delimiter
	return r
}

// 
func (r ApiListObjectVersionsRequest) EncodingType(encodingType string) ApiListObjectVersionsRequest {
	r.encodingType = &encodingType
	return r
}

// Specifies the key to start with when listing objects in a bucket.
func (r ApiListObjectVersionsRequest) KeyMarker(keyMarker string) ApiListObjectVersionsRequest {
	r.keyMarker = &keyMarker
	return r
}

// Sets the maximum number of keys returned in the response. By default the action returns up to 1,000 key names. The response might contain fewer keys but will never contain more. If additional keys satisfy the search criteria, but were not returned because max-keys was exceeded, the response contains &amp;lt;isTruncated&amp;gt;true&amp;lt;/isTruncated&amp;gt;. To return the additional keys, see key-marker and version-id-marker.
func (r ApiListObjectVersionsRequest) MaxKeys(maxKeys int32) ApiListObjectVersionsRequest {
	r.maxKeys = &maxKeys
	return r
}

// Use this parameter to select only those keys that begin with the specified prefix. You can use prefixes to separate a bucket into different groupings of keys. (You can think of using prefix to make groups in the same way you&#39;d use a folder in a file system.) You can use prefix with delimiter to roll up numerous objects into a single result under CommonPrefixes. 
func (r ApiListObjectVersionsRequest) Prefix(prefix string) ApiListObjectVersionsRequest {
	r.prefix = &prefix
	return r
}

// Specifies the object version you want to start listing from.
func (r ApiListObjectVersionsRequest) VersionIdMarker(versionIdMarker string) ApiListObjectVersionsRequest {
	r.versionIdMarker = &versionIdMarker
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiListObjectVersionsRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiListObjectVersionsRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

// Pagination limit
func (r ApiListObjectVersionsRequest) MaxKeys2(maxKeys2 string) ApiListObjectVersionsRequest {
	r.maxKeys2 = &maxKeys2
	return r
}

// Pagination token
func (r ApiListObjectVersionsRequest) KeyMarker2(keyMarker2 string) ApiListObjectVersionsRequest {
	r.keyMarker2 = &keyMarker2
	return r
}

// Pagination token
func (r ApiListObjectVersionsRequest) VersionIdMarker2(versionIdMarker2 string) ApiListObjectVersionsRequest {
	r.versionIdMarker2 = &versionIdMarker2
	return r
}

func (r ApiListObjectVersionsRequest) Execute() (*ListObjectVersionsOutput, *http.Response, error) {
	return r.ApiService.ListObjectVersionsExecute(r)
}

/*
ListObjectVersions Method for ListObjectVersions

<p>Returns metadata about all versions of the objects in a bucket. You can also use request parameters as selection criteria to return metadata about a subset of all the object versions.</p> <important> <p> To use this operation, you must have permissions to perform the <code>s3:ListBucketVersions</code> action. Be aware of the name difference. </p> </important> <note> <p> A 200 OK response can contain valid or invalid XML. Make sure to design your application to parse the contents of the response and handle it appropriately.</p> </note> <p>To use this operation, you must have READ access to the bucket.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket The bucket name that contains the objects. 
 @return ApiListObjectVersionsRequest
*/
func (a *BucketAPIService) ListObjectVersions(ctx context.Context, bucket string) ApiListObjectVersionsRequest {
	return ApiListObjectVersionsRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
//  @return ListObjectVersionsOutput
func (a *BucketAPIService) ListObjectVersionsExecute(r ApiListObjectVersionsRequest) (*ListObjectVersionsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListObjectVersionsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketAPIService.ListObjectVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}#versions"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.versions == nil {
		return localVarReturnValue, nil, reportError("versions is required and must be specified")
	}

	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "")
	}
	if r.encodingType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encoding-type", r.encodingType, "")
	}
	if r.keyMarker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key-marker", r.keyMarker, "")
	}
	if r.maxKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-keys", r.maxKeys, "")
	}
	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "")
	}
	if r.versionIdMarker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version-id-marker", r.versionIdMarker, "")
	}
	if r.maxKeys2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxKeys", r.maxKeys2, "")
	}
	if r.keyMarker2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeyMarker", r.keyMarker2, "")
	}
	if r.versionIdMarker2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VersionIdMarker", r.versionIdMarker2, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "versions", r.versions, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListObjectsRequest struct {
	ctx context.Context
	ApiService *BucketAPIService
	bucket string
	delimiter *string
	encodingType *string
	marker *string
	maxKeys *int32
	prefix *string
	xAmzRequestPayer *string
	xAmzExpectedBucketOwner *string
	maxKeys2 *string
	marker2 *string
}

// A delimiter is a character you use to group keys.
func (r ApiListObjectsRequest) Delimiter(delimiter string) ApiListObjectsRequest {
	r.delimiter = &delimiter
	return r
}

// 
func (r ApiListObjectsRequest) EncodingType(encodingType string) ApiListObjectsRequest {
	r.encodingType = &encodingType
	return r
}

// Marker is where you want ArvanCloud S3 to start listing from. ArvanCloud S3 starts listing after this specified key. Marker can be any key in the bucket.
func (r ApiListObjectsRequest) Marker(marker string) ApiListObjectsRequest {
	r.marker = &marker
	return r
}

// Sets the maximum number of keys returned in the response. By default the action returns up to 1,000 key names. The response might contain fewer keys but will never contain more. 
func (r ApiListObjectsRequest) MaxKeys(maxKeys int32) ApiListObjectsRequest {
	r.maxKeys = &maxKeys
	return r
}

// Limits the response to keys that begin with the specified prefix.
func (r ApiListObjectsRequest) Prefix(prefix string) ApiListObjectsRequest {
	r.prefix = &prefix
	return r
}

// Confirms that the requester knows that she or he will be charged for the list objects request. Bucket owners need not specify this parameter in their requests.
func (r ApiListObjectsRequest) XAmzRequestPayer(xAmzRequestPayer string) ApiListObjectsRequest {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiListObjectsRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiListObjectsRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

// Pagination limit
func (r ApiListObjectsRequest) MaxKeys2(maxKeys2 string) ApiListObjectsRequest {
	r.maxKeys2 = &maxKeys2
	return r
}

// Pagination token
func (r ApiListObjectsRequest) Marker2(marker2 string) ApiListObjectsRequest {
	r.marker2 = &marker2
	return r
}

func (r ApiListObjectsRequest) Execute() (*ListObjectsOutput, *http.Response, error) {
	return r.ApiService.ListObjectsExecute(r)
}

/*
ListObjects Method for ListObjects

<p>Returns some or all (up to 1,000) of the objects in a bucket. You can use the request parameters as selection criteria to return a subset of the objects in a bucket. A 200 OK response can contain valid or invalid XML. Be sure to design your application to parse the contents of the response and handle it appropriately.</p> <important> <p>This action has been revised. We recommend that you use the newer version, <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html">ListObjectsV2</a>, when developing applications. For backward compatibility, ArvanCloud S3 continues to support <code>ListObjects</code>.</p> </important> <p>The following operations are related to <code>ListObjects</code>:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html">ListObjectsV2</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html">GetObject</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html">PutObject</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateBucket.html">CreateBucket</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListBuckets.html">ListBuckets</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The name of the bucket containing the objects.</p>
 @return ApiListObjectsRequest
*/
func (a *BucketAPIService) ListObjects(ctx context.Context, bucket string) ApiListObjectsRequest {
	return ApiListObjectsRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
//  @return ListObjectsOutput
func (a *BucketAPIService) ListObjectsExecute(r ApiListObjectsRequest) (*ListObjectsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListObjectsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketAPIService.ListObjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}#Listobjects"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "")
	}
	if r.encodingType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encoding-type", r.encodingType, "")
	}
	if r.marker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marker", r.marker, "")
	}
	if r.maxKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-keys", r.maxKeys, "")
	}
	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "")
	}
	if r.maxKeys2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxKeys", r.maxKeys2, "")
	}
	if r.marker2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Marker", r.marker2, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 480 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListObjectsV2Request struct {
	ctx context.Context
	ApiService *BucketAPIService
	bucket string
	listType *string
	xAmzSecurityToken *string
	delimiter *string
	encodingType *string
	maxKeys *int32
	prefix *string
	continuationToken *string
	fetchOwner *bool
	startAfter *string
	xAmzRequestPayer *string
	xAmzExpectedBucketOwner *string
	maxKeys2 *string
	continuationToken2 *string
}

func (r ApiListObjectsV2Request) ListType(listType string) ApiListObjectsV2Request {
	r.listType = &listType
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiListObjectsV2Request) XAmzSecurityToken(xAmzSecurityToken string) ApiListObjectsV2Request {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// A delimiter is a character you use to group keys.
func (r ApiListObjectsV2Request) Delimiter(delimiter string) ApiListObjectsV2Request {
	r.delimiter = &delimiter
	return r
}

// Encoding type used by ArvanCloud S3 to encode object keys in the response.
func (r ApiListObjectsV2Request) EncodingType(encodingType string) ApiListObjectsV2Request {
	r.encodingType = &encodingType
	return r
}

// Sets the maximum number of keys returned in the response. By default the action returns up to 1,000 key names. The response might contain fewer keys but will never contain more.
func (r ApiListObjectsV2Request) MaxKeys(maxKeys int32) ApiListObjectsV2Request {
	r.maxKeys = &maxKeys
	return r
}

// Limits the response to keys that begin with the specified prefix.
func (r ApiListObjectsV2Request) Prefix(prefix string) ApiListObjectsV2Request {
	r.prefix = &prefix
	return r
}

// ContinuationToken indicates ArvanCloud S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key.
func (r ApiListObjectsV2Request) ContinuationToken(continuationToken string) ApiListObjectsV2Request {
	r.continuationToken = &continuationToken
	return r
}

// The owner field is not present in listV2 by default, if you want to return owner field with each key in the result then set the fetch owner field to true.
func (r ApiListObjectsV2Request) FetchOwner(fetchOwner bool) ApiListObjectsV2Request {
	r.fetchOwner = &fetchOwner
	return r
}

// StartAfter is where you want ArvanCloud S3 to start listing from. ArvanCloud S3 starts listing after this specified key. StartAfter can be any key in the bucket.
func (r ApiListObjectsV2Request) StartAfter(startAfter string) ApiListObjectsV2Request {
	r.startAfter = &startAfter
	return r
}

// Confirms that the requester knows that she or he will be charged for the list objects request in V2 style. Bucket owners need not specify this parameter in their requests.
func (r ApiListObjectsV2Request) XAmzRequestPayer(xAmzRequestPayer string) ApiListObjectsV2Request {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiListObjectsV2Request) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiListObjectsV2Request {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

// Pagination limit
func (r ApiListObjectsV2Request) MaxKeys2(maxKeys2 string) ApiListObjectsV2Request {
	r.maxKeys2 = &maxKeys2
	return r
}

// Pagination token
func (r ApiListObjectsV2Request) ContinuationToken2(continuationToken2 string) ApiListObjectsV2Request {
	r.continuationToken2 = &continuationToken2
	return r
}

func (r ApiListObjectsV2Request) Execute() (*ListObjectsV2Output, *http.Response, error) {
	return r.ApiService.ListObjectsV2Execute(r)
}

/*
ListObjectsV2 Method for ListObjectsV2

<p>Returns some or all (up to 1,000) of the objects in a bucket with each request. You can use the request parameters as selection criteria to return a subset of the objects in a bucket. A <code>200 OK</code> response can contain valid or invalid XML. Make sure to design your application to parse the contents of the response and handle it appropriately. Objects are returned sorted in an ascending order of the respective key names in the list. For more information about listing objects, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/ListingKeysUsingAPIs.html">Listing object keys programmatically</a> </p> <p>To use this operation, you must have READ access to the bucket.</p> <p>To use this action in an Identity and Access Management (IAM) policy, you must have permissions to perform the <code>s3:ListBucket</code> action. The bucket owner has this permission by default and can grant this permission to others. For more information about permissions, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-with-s3-actions.html#using-with-s3-actions-related-to-bucket-subresources">Permissions Related to Bucket Subresource Operations</a> and <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-access-control.html">Managing Access Permissions to Your ArvanCloud S3 Resources</a>.</p> <important> <p>This section describes the latest revision of this action. We recommend that you use this revised API for application development. For backward compatibility, ArvanCloud S3 continues to support the prior version of this API, <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html">ListObjects</a>.</p> </important> <p>To get a list of your buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListBuckets.html">ListBuckets</a>.</p> <p>The following operations are related to <code>ListObjectsV2</code>:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html">GetObject</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html">PutObject</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateBucket.html">CreateBucket</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>Bucket name to list. </p> </p>
 @return ApiListObjectsV2Request
*/
func (a *BucketAPIService) ListObjectsV2(ctx context.Context, bucket string) ApiListObjectsV2Request {
	return ApiListObjectsV2Request{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
//  @return ListObjectsV2Output
func (a *BucketAPIService) ListObjectsV2Execute(r ApiListObjectsV2Request) (*ListObjectsV2Output, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListObjectsV2Output
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketAPIService.ListObjectsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}#list-type=2"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listType == nil {
		return localVarReturnValue, nil, reportError("listType is required and must be specified")
	}

	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "")
	}
	if r.encodingType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encoding-type", r.encodingType, "")
	}
	if r.maxKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-keys", r.maxKeys, "")
	}
	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "")
	}
	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuation-token", r.continuationToken, "")
	}
	if r.fetchOwner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch-owner", r.fetchOwner, "")
	}
	if r.startAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start-after", r.startAfter, "")
	}
	if r.maxKeys2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxKeys", r.maxKeys2, "")
	}
	if r.continuationToken2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ContinuationToken", r.continuationToken2, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "list-type", r.listType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 480 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutPublicAccessBlockRequest struct {
	ctx context.Context
	ApiService *BucketAPIService
	bucket string
	publicAccessBlock *bool
	putPublicAccessBlockRequest *PutPublicAccessBlockRequest
	xAmzSecurityToken *string
	contentMD5 *string
	xAmzExpectedBucketOwner *string
}

func (r ApiPutPublicAccessBlockRequest) PublicAccessBlock(publicAccessBlock bool) ApiPutPublicAccessBlockRequest {
	r.publicAccessBlock = &publicAccessBlock
	return r
}

func (r ApiPutPublicAccessBlockRequest) PutPublicAccessBlockRequest(putPublicAccessBlockRequest PutPublicAccessBlockRequest) ApiPutPublicAccessBlockRequest {
	r.putPublicAccessBlockRequest = &putPublicAccessBlockRequest
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiPutPublicAccessBlockRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiPutPublicAccessBlockRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// &lt;p&gt;The MD5 hash of the &lt;code&gt;PutPublicAccessBlock&lt;/code&gt; request body. &lt;/p&gt; &lt;p&gt;For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.&lt;/p&gt;
func (r ApiPutPublicAccessBlockRequest) ContentMD5(contentMD5 string) ApiPutPublicAccessBlockRequest {
	r.contentMD5 = &contentMD5
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiPutPublicAccessBlockRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiPutPublicAccessBlockRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiPutPublicAccessBlockRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutPublicAccessBlockExecute(r)
}

/*
PutPublicAccessBlock Method for PutPublicAccessBlock

<p>Creates or modifies the <code>PublicAccessBlock</code> configuration for an ArvanCloud S3 bucket. To use this operation, you must have the <code>s3:PutBucketPublicAccessBlock</code> permission. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket The name of the ArvanCloud S3 bucket whose <code>PublicAccessBlock</code> configuration you want to set.
 @return ApiPutPublicAccessBlockRequest
*/
func (a *BucketAPIService) PutPublicAccessBlock(ctx context.Context, bucket string) ApiPutPublicAccessBlockRequest {
	return ApiPutPublicAccessBlockRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
func (a *BucketAPIService) PutPublicAccessBlockExecute(r ApiPutPublicAccessBlockRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketAPIService.PutPublicAccessBlock")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}#publicAccessBlock"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.publicAccessBlock == nil {
		return nil, reportError("publicAccessBlock is required and must be specified")
	}
	if r.putPublicAccessBlockRequest == nil {
		return nil, reportError("putPublicAccessBlockRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "publicAccessBlock", r.publicAccessBlock, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.contentMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-MD5", r.contentMD5, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	// body params
	localVarPostBody = r.putPublicAccessBlockRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
