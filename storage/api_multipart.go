/*
ArvanCloud S3 Services

<p/>

API version: 2006-03-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package storage

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// MultipartAPIService MultipartAPI service
type MultipartAPIService service

type ApiAbortMultipartUploadRequest struct {
	ctx context.Context
	ApiService *MultipartAPIService
	bucket string
	key string
	uploadId *string
	xAmzSecurityToken *string
	xAmzRequestPayer *string
	xAmzExpectedBucketOwner *string
}

// Upload ID that identifies the multipart upload.
func (r ApiAbortMultipartUploadRequest) UploadId(uploadId string) ApiAbortMultipartUploadRequest {
	r.uploadId = &uploadId
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiAbortMultipartUploadRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiAbortMultipartUploadRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// 
func (r ApiAbortMultipartUploadRequest) XAmzRequestPayer(xAmzRequestPayer string) ApiAbortMultipartUploadRequest {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiAbortMultipartUploadRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiAbortMultipartUploadRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiAbortMultipartUploadRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AbortMultipartUploadExecute(r)
}

/*
AbortMultipartUpload Method for AbortMultipartUpload

<p>This action aborts a multipart upload. After a multipart upload is aborted, no additional parts can be uploaded using that upload ID. The storage consumed by any previously uploaded parts will be freed. However, if any part uploads are currently in progress, those part uploads might or might not succeed. As a result, it might be necessary to abort a given multipart upload multiple times in order to completely free all storage consumed by all parts. </p> <p>To verify that all parts have been removed, so you don't get charged for the part storage, you should call the <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListParts.html">ListParts</a> action and ensure that the parts list is empty.</p> <p>For information about permissions required to use the multipart upload, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuAndPermissions.html">Multipart Upload and Permissions</a>.</p> <p>The following operations are related to <code>AbortMultipartUpload</code>:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html">CreateMultipartUpload</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPart.html">UploadPart</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CompleteMultipartUpload.html">CompleteMultipartUpload</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListParts.html">ListParts</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListMultipartUploads.html">ListMultipartUploads</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The bucket name to which the upload was taking place. </p>
 @param key Key of the object for which the multipart upload was initiated.
 @return ApiAbortMultipartUploadRequest
*/
func (a *MultipartAPIService) AbortMultipartUpload(ctx context.Context, bucket string, key string) ApiAbortMultipartUploadRequest {
	return ApiAbortMultipartUploadRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
		key: key,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MultipartAPIService) AbortMultipartUploadExecute(r ApiAbortMultipartUploadRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultipartAPIService.AbortMultipartUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}#uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 480 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCompleteMultipartUploadRequest struct {
	ctx context.Context
	ApiService *MultipartAPIService
	bucket string
	key string
	uploadId *string
	completeMultipartUploadRequest *CompleteMultipartUploadRequest
	xAmzSecurityToken *string
	xAmzRequestPayer *string
	xAmzExpectedBucketOwner *string
}

// ID for the initiated multipart upload.
func (r ApiCompleteMultipartUploadRequest) UploadId(uploadId string) ApiCompleteMultipartUploadRequest {
	r.uploadId = &uploadId
	return r
}

func (r ApiCompleteMultipartUploadRequest) CompleteMultipartUploadRequest(completeMultipartUploadRequest CompleteMultipartUploadRequest) ApiCompleteMultipartUploadRequest {
	r.completeMultipartUploadRequest = &completeMultipartUploadRequest
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiCompleteMultipartUploadRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiCompleteMultipartUploadRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// 
func (r ApiCompleteMultipartUploadRequest) XAmzRequestPayer(xAmzRequestPayer string) ApiCompleteMultipartUploadRequest {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiCompleteMultipartUploadRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiCompleteMultipartUploadRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiCompleteMultipartUploadRequest) Execute() (*CompleteMultipartUploadOutput, *http.Response, error) {
	return r.ApiService.CompleteMultipartUploadExecute(r)
}

/*
CompleteMultipartUpload Method for CompleteMultipartUpload

<p>Completes a multipart upload by assembling previously uploaded parts.</p> <p>You first initiate the multipart upload and then upload all parts using the <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPart.html">UploadPart</a> operation. After successfully uploading all relevant parts of an upload, you call this action to complete the upload. Upon receiving this request, ArvanCloud S3 concatenates all the parts in ascending order by part number to create a new object. In the Complete Multipart Upload request, you must provide the parts list. You must ensure that the parts list is complete. This action concatenates the parts that you provide in the list. For each part in the list, you must provide the part number and the <code>ETag</code> value, returned after that part was uploaded.</p> <p>Processing of a Complete Multipart Upload request could take several minutes to complete. After ArvanCloud S3 begins processing the request, it sends an HTTP response header that specifies a 200 OK response. While processing is in progress, ArvanCloud S3 periodically sends white space characters to keep the connection from timing out. Because a request could fail after the initial 200 OK response has been sent, it is important that you check the response body to determine whether the request succeeded.</p> <p>Note that if <code>CompleteMultipartUpload</code> fails, applications should be prepared to retry the failed requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ErrorBestPractices.html">ArvanCloud S3 Error Best Practices</a>.</p> <p>For more information about multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/uploadobjusingmpu.html">Uploading Objects Using Multipart Upload</a>.</p> <p>For information about permissions required to use the multipart upload API, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuAndPermissions.html">Multipart Upload and Permissions</a>.</p> <p> <code>CompleteMultipartUpload</code> has the following special errors:</p> <ul> <li> <p>Error code: <code>EntityTooSmall</code> </p> <ul> <li> <p>Description: Your proposed upload is smaller than the minimum allowed object size. Each part must be at least 5 MB in size, except the last part.</p> </li> <li> <p>400 Bad Request</p> </li> </ul> </li> <li> <p>Error code: <code>InvalidPart</code> </p> <ul> <li> <p>Description: One or more of the specified parts could not be found. The part might not have been uploaded, or the specified entity tag might not have matched the part's entity tag.</p> </li> <li> <p>400 Bad Request</p> </li> </ul> </li> <li> <p>Error code: <code>InvalidPartOrder</code> </p> <ul> <li> <p>Description: The list of parts was not in ascending order. The parts list must be specified in order by part number.</p> </li> <li> <p>400 Bad Request</p> </li> </ul> </li> <li> <p>Error code: <code>NoSuchUpload</code> </p> <ul> <li> <p>Description: The specified multipart upload does not exist. The upload ID might be invalid, or the multipart upload might have been aborted or completed.</p> </li> <li> <p>404 Not Found</p> </li> </ul> </li> </ul> <p>The following operations are related to <code>CompleteMultipartUpload</code>:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html">CreateMultipartUpload</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPart.html">UploadPart</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_AbortMultipartUpload.html">AbortMultipartUpload</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListParts.html">ListParts</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListMultipartUploads.html">ListMultipartUploads</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>Name of the bucket to which the multipart upload was initiated.</p> </p>
 @param key Object key for which the multipart upload was initiated.
 @return ApiCompleteMultipartUploadRequest
*/
func (a *MultipartAPIService) CompleteMultipartUpload(ctx context.Context, bucket string, key string) ApiCompleteMultipartUploadRequest {
	return ApiCompleteMultipartUploadRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
		key: key,
	}
}

// Execute executes the request
//  @return CompleteMultipartUploadOutput
func (a *MultipartAPIService) CompleteMultipartUploadExecute(r ApiCompleteMultipartUploadRequest) (*CompleteMultipartUploadOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompleteMultipartUploadOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultipartAPIService.CompleteMultipartUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}#uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}
	if r.completeMultipartUploadRequest == nil {
		return localVarReturnValue, nil, reportError("completeMultipartUploadRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	// body params
	localVarPostBody = r.completeMultipartUploadRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMultipartUploadRequest struct {
	ctx context.Context
	ApiService *MultipartAPIService
	bucket string
	key string
	uploads *bool
	createMultipartUploadRequest *CreateMultipartUploadRequest
	xAmzSecurityToken *string
	xAmzAcl *string
	cacheControl *string
	contentDisposition *string
	contentEncoding *string
	contentLanguage *string
	contentType *string
	expires *time.Time
	xAmzGrantFullControl *string
	xAmzGrantRead *string
	xAmzGrantReadAcp *string
	xAmzGrantWriteAcp *string
	xAmzServerSideEncryption *string
	xAmzStorageClass *string
	xAmzWebsiteRedirectLocation *string
	xAmzServerSideEncryptionCustomerAlgorithm *string
	xAmzServerSideEncryptionCustomerKey *string
	xAmzServerSideEncryptionCustomerKeyMD5 *string
	xAmzServerSideEncryptionAwsKmsKeyId *string
	xAmzServerSideEncryptionContext *string
	xAmzServerSideEncryptionBucketKeyEnabled *bool
	xAmzRequestPayer *string
	xAmzTagging *string
	xAmzObjectLockMode *string
	xAmzObjectLockRetainUntilDate *time.Time
	xAmzObjectLockLegalHold *string
	xAmzExpectedBucketOwner *string
}

func (r ApiCreateMultipartUploadRequest) Uploads(uploads bool) ApiCreateMultipartUploadRequest {
	r.uploads = &uploads
	return r
}

func (r ApiCreateMultipartUploadRequest) CreateMultipartUploadRequest(createMultipartUploadRequest CreateMultipartUploadRequest) ApiCreateMultipartUploadRequest {
	r.createMultipartUploadRequest = &createMultipartUploadRequest
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiCreateMultipartUploadRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiCreateMultipartUploadRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// &lt;p&gt;The canned ACL to apply to the object.&lt;/p&gt; &lt;/p&gt;
func (r ApiCreateMultipartUploadRequest) XAmzAcl(xAmzAcl string) ApiCreateMultipartUploadRequest {
	r.xAmzAcl = &xAmzAcl
	return r
}

// Specifies caching behavior along the request/reply chain.
func (r ApiCreateMultipartUploadRequest) CacheControl(cacheControl string) ApiCreateMultipartUploadRequest {
	r.cacheControl = &cacheControl
	return r
}

// Specifies presentational information for the object.
func (r ApiCreateMultipartUploadRequest) ContentDisposition(contentDisposition string) ApiCreateMultipartUploadRequest {
	r.contentDisposition = &contentDisposition
	return r
}

// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.
func (r ApiCreateMultipartUploadRequest) ContentEncoding(contentEncoding string) ApiCreateMultipartUploadRequest {
	r.contentEncoding = &contentEncoding
	return r
}

// The language the content is in.
func (r ApiCreateMultipartUploadRequest) ContentLanguage(contentLanguage string) ApiCreateMultipartUploadRequest {
	r.contentLanguage = &contentLanguage
	return r
}

// A standard MIME type describing the format of the object data.
func (r ApiCreateMultipartUploadRequest) ContentType(contentType string) ApiCreateMultipartUploadRequest {
	r.contentType = &contentType
	return r
}

// The date and time at which the object is no longer cacheable.
func (r ApiCreateMultipartUploadRequest) Expires(expires time.Time) ApiCreateMultipartUploadRequest {
	r.expires = &expires
	return r
}

// &lt;p&gt;Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.&lt;/p&gt; &lt;/p&gt;
func (r ApiCreateMultipartUploadRequest) XAmzGrantFullControl(xAmzGrantFullControl string) ApiCreateMultipartUploadRequest {
	r.xAmzGrantFullControl = &xAmzGrantFullControl
	return r
}

// &lt;p&gt;Allows grantee to read the object data and its metadata.&lt;/p&gt; &lt;/p&gt;
func (r ApiCreateMultipartUploadRequest) XAmzGrantRead(xAmzGrantRead string) ApiCreateMultipartUploadRequest {
	r.xAmzGrantRead = &xAmzGrantRead
	return r
}

// &lt;p&gt;Allows grantee to read the object ACL.&lt;/p&gt; &lt;/p&gt;
func (r ApiCreateMultipartUploadRequest) XAmzGrantReadAcp(xAmzGrantReadAcp string) ApiCreateMultipartUploadRequest {
	r.xAmzGrantReadAcp = &xAmzGrantReadAcp
	return r
}

// &lt;p&gt;Allows grantee to write the ACL for the applicable object.&lt;/p&gt; &lt;/p&gt;
func (r ApiCreateMultipartUploadRequest) XAmzGrantWriteAcp(xAmzGrantWriteAcp string) ApiCreateMultipartUploadRequest {
	r.xAmzGrantWriteAcp = &xAmzGrantWriteAcp
	return r
}

// The server-side encryption algorithm used when storing this object in ArvanCloud S3 (for example, AES256, aws:kms).
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryption(xAmzServerSideEncryption string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryption = &xAmzServerSideEncryption
	return r
}

// By default, ArvanCloud S3 uses the STANDARD Storage Class to store newly created objects. The STANDARD storage class provides high durability and high availability. Depending on performance needs, you can specify a different Storage Class.
func (r ApiCreateMultipartUploadRequest) XAmzStorageClass(xAmzStorageClass string) ApiCreateMultipartUploadRequest {
	r.xAmzStorageClass = &xAmzStorageClass
	return r
}

// If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. ArvanCloud S3 stores the value of this header in the object metadata.
func (r ApiCreateMultipartUploadRequest) XAmzWebsiteRedirectLocation(xAmzWebsiteRedirectLocation string) ApiCreateMultipartUploadRequest {
	r.xAmzWebsiteRedirectLocation = &xAmzWebsiteRedirectLocation
	return r
}

// Specifies the algorithm to use to when encrypting the object (for example, AES256).
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryptionCustomerAlgorithm(xAmzServerSideEncryptionCustomerAlgorithm string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryptionCustomerAlgorithm = &xAmzServerSideEncryptionCustomerAlgorithm
	return r
}

// Specifies the customer-provided encryption key for ArvanCloud S3 to use in encrypting data. This value is used to store the object and then it is discarded; ArvanCloud S3 does not store the encryption key. The key must be appropriate for use with the algorithm specified in the &lt;code&gt;x-amz-server-side-encryption-customer-algorithm&lt;/code&gt; header.
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryptionCustomerKey(xAmzServerSideEncryptionCustomerKey string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryptionCustomerKey = &xAmzServerSideEncryptionCustomerKey
	return r
}

// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. ArvanCloud S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryptionCustomerKeyMD5(xAmzServerSideEncryptionCustomerKeyMD5 string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryptionCustomerKeyMD5 = &xAmzServerSideEncryptionCustomerKeyMD5
	return r
}

// Specifies the ID of the symmetric customer managed key to use for object encryption. All GET and PUT requests for an object protected by Amazon Web Services KMS will fail if not made via SSL or using SigV4. For information about configuring using any of the officially supported Amazon Web Services SDKs and Amazon Web Services CLI, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version\&quot;&gt;Specifying the Signature Version in Request Authentication&lt;/a&gt; in the &lt;i&gt;S3 User Guide&lt;/i&gt;.
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryptionAwsKmsKeyId(xAmzServerSideEncryptionAwsKmsKeyId string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryptionAwsKmsKeyId = &xAmzServerSideEncryptionAwsKmsKeyId
	return r
}

// Specifies the Amazon Web Services KMS Encryption Context to use for object encryption. The value of this header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryptionContext(xAmzServerSideEncryptionContext string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryptionContext = &xAmzServerSideEncryptionContext
	return r
}

// &lt;p&gt;Specifies whether ArvanCloud S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to &lt;code&gt;true&lt;/code&gt; causes ArvanCloud S3 to use an S3 Bucket Key for object encryption with SSE-KMS.&lt;/p&gt; &lt;p&gt;Specifying this header with an object action doesn’t affect bucket-level settings for S3 Bucket Key.&lt;/p&gt;
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryptionBucketKeyEnabled(xAmzServerSideEncryptionBucketKeyEnabled bool) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryptionBucketKeyEnabled = &xAmzServerSideEncryptionBucketKeyEnabled
	return r
}

// 
func (r ApiCreateMultipartUploadRequest) XAmzRequestPayer(xAmzRequestPayer string) ApiCreateMultipartUploadRequest {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

// The tag-set for the object. The tag-set must be encoded as URL Query parameters.
func (r ApiCreateMultipartUploadRequest) XAmzTagging(xAmzTagging string) ApiCreateMultipartUploadRequest {
	r.xAmzTagging = &xAmzTagging
	return r
}

// Specifies the Object Lock mode that you want to apply to the uploaded object.
func (r ApiCreateMultipartUploadRequest) XAmzObjectLockMode(xAmzObjectLockMode string) ApiCreateMultipartUploadRequest {
	r.xAmzObjectLockMode = &xAmzObjectLockMode
	return r
}

// Specifies the date and time when you want the Object Lock to expire.
func (r ApiCreateMultipartUploadRequest) XAmzObjectLockRetainUntilDate(xAmzObjectLockRetainUntilDate time.Time) ApiCreateMultipartUploadRequest {
	r.xAmzObjectLockRetainUntilDate = &xAmzObjectLockRetainUntilDate
	return r
}

// Specifies whether you want to apply a Legal Hold to the uploaded object.
func (r ApiCreateMultipartUploadRequest) XAmzObjectLockLegalHold(xAmzObjectLockLegalHold string) ApiCreateMultipartUploadRequest {
	r.xAmzObjectLockLegalHold = &xAmzObjectLockLegalHold
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiCreateMultipartUploadRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiCreateMultipartUploadRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiCreateMultipartUploadRequest) Execute() (*CreateMultipartUploadOutput, *http.Response, error) {
	return r.ApiService.CreateMultipartUploadExecute(r)
}

/*
CreateMultipartUpload Method for CreateMultipartUpload

<p>This action initiates a multipart upload and returns an upload ID. This upload ID is used to associate all of the parts in the specific multipart upload. You specify this upload ID in each of your subsequent upload part requests (see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPart.html">UploadPart</a>). You also include this upload ID in the final request to either complete or abort the multipart upload request.</p> <p>For more information about multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html">Multipart Upload Overview</a>.</p> <p>If you have configured a lifecycle rule to abort incomplete multipart uploads, the upload must complete within the number of days specified in the bucket lifecycle configuration. Otherwise, the incomplete multipart upload becomes eligible for an abort action and ArvanCloud S3 aborts the multipart upload. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config">Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy</a>.</p> <p>For information about the permissions required to use the multipart upload API, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuAndPermissions.html">Multipart Upload and Permissions</a>.</p> <p>For request signing, multipart upload is just a series of regular requests. You initiate a multipart upload, send one or more requests to upload parts, and then complete the multipart upload process. You sign each request individually. There is nothing special about signing multipart upload requests. For more information about signing, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html">Authenticating Requests (Amazon Web Services Signature Version 4)</a>.</p> <note> <p> After you initiate a multipart upload and upload one or more parts, to stop being charged for storing the uploaded parts, you must either complete or abort the multipart upload. ArvanCloud S3 frees up the space used to store the parts and stop charging you for storing them only after you either complete or abort a multipart upload. </p> </note> <p>You can optionally request server-side encryption. For server-side encryption, ArvanCloud S3 encrypts your data as it writes it to disks in its data centers and decrypts it when you access it. You can provide your own encryption key, or use Amazon Web Services KMS keys or ArvanCloud S3-managed encryption keys. If you choose to provide your own encryption key, the request headers you provide in <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPart.html">UploadPart</a> and <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPartCopy.html">UploadPartCopy</a> requests must match the headers you used in the request to initiate the upload by using <code>CreateMultipartUpload</code>. </p> <p>To perform a multipart upload with encryption using an Amazon Web Services KMS key, the requester must have permission to the <code>kms:Decrypt</code> and <code>kms:GenerateDataKey*</code> actions on the key. These permissions are required because ArvanCloud S3 must decrypt and read data from the encrypted file parts before it completes the multipart upload. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/mpuoverview.html#mpuAndPermissions">Multipart upload API and permissions</a> in the <i>S3 User Guide</i>.</p> <p>If your Identity and Access Management (IAM) user or role is in the same Amazon Web Services account as the KMS key, then you must have these permissions on the key policy. If your IAM user or role belongs to a different account than the key, then you must have the permissions on both the key policy and your IAM user or role.</p> <p> For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html">Protecting Data Using Server-Side Encryption</a>.</p> <dl> <dt>Access Permissions</dt> <dd> <p>When copying an object, you can optionally specify the accounts or groups that should be granted specific permissions on the new object. There are two ways to grant the permissions using the request headers:</p> <ul> <li> <p>Specify a canned ACL with the <code>x-amz-acl</code> request header. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned ACL</a>.</p> </li> <li> <p>Specify access permissions explicitly with the <code>x-amz-grant-read</code>, <code>x-amz-grant-read-acp</code>, <code>x-amz-grant-write-acp</code>, and <code>x-amz-grant-full-control</code> headers. These parameters map to the set of permissions that ArvanCloud S3 supports in an ACL. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html">Access Control List (ACL) Overview</a>.</p> </li> </ul> <p>You can use either a canned ACL or specify access permissions explicitly. You cannot do both.</p> </dd> <dt>Server-Side- Encryption-Specific Request Headers</dt> <dd> <p>You can optionally tell ArvanCloud S3 to encrypt data at rest using server-side encryption. Server-side encryption is for data encryption at rest. ArvanCloud S3 encrypts your data as it writes it to disks in its data centers and decrypts it when you access it. The option you use depends on whether you want to use Amazon Web Services managed encryption keys or provide your own encryption key. </p> <ul> <li> <p>Use encryption keys managed by ArvanCloud S3 or customer managed key stored in Amazon Web Services Key Management Service (Amazon Web Services KMS) – If you want Amazon Web Services to manage the keys used to encrypt data, specify the following headers in the request.</p> <ul> <li> <p>x-amz-server-side-encryption</p> </li> <li> <p>x-amz-server-side-encryption-aws-kms-key-id</p> </li> <li> <p>x-amz-server-side-encryption-context</p> </li> </ul> <note> <p>If you specify <code>x-amz-server-side-encryption:aws:kms</code>, but don't provide <code>x-amz-server-side-encryption-aws-kms-key-id</code>, ArvanCloud S3 uses the Amazon Web Services managed key in Amazon Web Services KMS to protect the data.</p> </note> <important> <p>All GET and PUT requests for an object protected by Amazon Web Services KMS fail if you don't make them with SSL or by using SigV4.</p> </important> <p>For more information about server-side encryption with KMS key (SSE-KMS), see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">Protecting Data Using Server-Side Encryption with KMS keys</a>.</p> </li> <li> <p>Use customer-provided encryption keys – If you want to manage your own encryption keys, provide all the following headers in the request.</p> <ul> <li> <p>x-amz-server-side-encryption-customer-algorithm</p> </li> <li> <p>x-amz-server-side-encryption-customer-key</p> </li> <li> <p>x-amz-server-side-encryption-customer-key-MD5</p> </li> </ul> <p>For more information about server-side encryption with KMS keys (SSE-KMS), see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">Protecting Data Using Server-Side Encryption with KMS keys</a>.</p> </li> </ul> </dd> <dt>Access-Control-List (ACL)-Specific Request Headers</dt> <dd> <p>You also can use the following access control–related headers with this operation. By default, all objects are private. Only the owner has full access control. When adding a new object, you can grant permissions to individual Amazon Web Services accounts or to predefined groups defined by ArvanCloud S3. These permissions are then added to the access control list (ACL) on the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/S3_ACLs_UsingACLs.html">Using ACLs</a>. With this operation, you can grant access permissions using one of the following two methods:</p> <ul> <li> <p>Specify a canned ACL (<code>x-amz-acl</code>) — ArvanCloud S3 supports a set of predefined ACLs, known as <i>canned ACLs</i>. Each canned ACL has a predefined set of grantees and permissions. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#CannedACL">Canned ACL</a>.</p> </li> <li> <p>Specify access permissions explicitly — To explicitly grant access permissions to specific Amazon Web Services accounts or groups, use the following headers. Each header maps to specific permissions that ArvanCloud S3 supports in an ACL. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html">Access Control List (ACL) Overview</a>. In the header, you specify a list of grantees who get the specific permission. To grant permissions explicitly, use:</p> <ul> <li> <p>x-amz-grant-read</p> </li> <li> <p>x-amz-grant-write</p> </li> <li> <p>x-amz-grant-read-acp</p> </li> <li> <p>x-amz-grant-write-acp</p> </li> <li> <p>x-amz-grant-full-control</p> </li> </ul> <p>You specify each grantee as a type=value pair, where the type is one of the following:</p> <ul> <li> <p> <code>id</code> – if the value specified is the canonical user ID of an Amazon Web Services account</p> </li> <li> <p> <code>uri</code> – if you are granting permissions to a predefined group</p> </li> <li> <p> <code>emailAddress</code> – if the value specified is the email address of an Amazon Web Services account</p> <note> <p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The name of the bucket to which to initiate the upload</p> <p>
 @param key Object key for which the multipart upload is to be initiated.
 @return ApiCreateMultipartUploadRequest
*/
func (a *MultipartAPIService) CreateMultipartUpload(ctx context.Context, bucket string, key string) ApiCreateMultipartUploadRequest {
	return ApiCreateMultipartUploadRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
		key: key,
	}
}

// Execute executes the request
//  @return CreateMultipartUploadOutput
func (a *MultipartAPIService) CreateMultipartUploadExecute(r ApiCreateMultipartUploadRequest) (*CreateMultipartUploadOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateMultipartUploadOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultipartAPIService.CreateMultipartUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}#uploads"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.uploads == nil {
		return localVarReturnValue, nil, reportError("uploads is required and must be specified")
	}
	if r.createMultipartUploadRequest == nil {
		return localVarReturnValue, nil, reportError("createMultipartUploadRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "uploads", r.uploads, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzAcl != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-acl", r.xAmzAcl, "")
	}
	if r.cacheControl != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Cache-Control", r.cacheControl, "")
	}
	if r.contentDisposition != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Disposition", r.contentDisposition, "")
	}
	if r.contentEncoding != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Encoding", r.contentEncoding, "")
	}
	if r.contentLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Language", r.contentLanguage, "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
	}
	if r.expires != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Expires", r.expires, "")
	}
	if r.xAmzGrantFullControl != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-grant-full-control", r.xAmzGrantFullControl, "")
	}
	if r.xAmzGrantRead != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-grant-read", r.xAmzGrantRead, "")
	}
	if r.xAmzGrantReadAcp != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-grant-read-acp", r.xAmzGrantReadAcp, "")
	}
	if r.xAmzGrantWriteAcp != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-grant-write-acp", r.xAmzGrantWriteAcp, "")
	}
	if r.xAmzServerSideEncryption != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption", r.xAmzServerSideEncryption, "")
	}
	if r.xAmzStorageClass != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-storage-class", r.xAmzStorageClass, "")
	}
	if r.xAmzWebsiteRedirectLocation != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-website-redirect-location", r.xAmzWebsiteRedirectLocation, "")
	}
	if r.xAmzServerSideEncryptionCustomerAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-algorithm", r.xAmzServerSideEncryptionCustomerAlgorithm, "")
	}
	if r.xAmzServerSideEncryptionCustomerKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key", r.xAmzServerSideEncryptionCustomerKey, "")
	}
	if r.xAmzServerSideEncryptionCustomerKeyMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key-MD5", r.xAmzServerSideEncryptionCustomerKeyMD5, "")
	}
	if r.xAmzServerSideEncryptionAwsKmsKeyId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-aws-kms-key-id", r.xAmzServerSideEncryptionAwsKmsKeyId, "")
	}
	if r.xAmzServerSideEncryptionContext != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-context", r.xAmzServerSideEncryptionContext, "")
	}
	if r.xAmzServerSideEncryptionBucketKeyEnabled != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-bucket-key-enabled", r.xAmzServerSideEncryptionBucketKeyEnabled, "")
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	if r.xAmzTagging != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-tagging", r.xAmzTagging, "")
	}
	if r.xAmzObjectLockMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-object-lock-mode", r.xAmzObjectLockMode, "")
	}
	if r.xAmzObjectLockRetainUntilDate != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-object-lock-retain-until-date", r.xAmzObjectLockRetainUntilDate, "")
	}
	if r.xAmzObjectLockLegalHold != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-object-lock-legal-hold", r.xAmzObjectLockLegalHold, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	// body params
	localVarPostBody = r.createMultipartUploadRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMultipartUploadsRequest struct {
	ctx context.Context
	ApiService *MultipartAPIService
	bucket string
	uploads *bool
	xAmzSecurityToken *string
	delimiter *string
	encodingType *string
	keyMarker *string
	maxUploads *int32
	prefix *string
	uploadIdMarker *string
	xAmzExpectedBucketOwner *string
	maxUploads2 *string
	keyMarker2 *string
	uploadIdMarker2 *string
}

func (r ApiListMultipartUploadsRequest) Uploads(uploads bool) ApiListMultipartUploadsRequest {
	r.uploads = &uploads
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiListMultipartUploadsRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiListMultipartUploadsRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// &lt;p&gt;Character you use to group keys.&lt;/p&gt; &lt;p&gt;All keys that contain the same string between the prefix, if specified, and the first occurrence of the delimiter after the prefix are grouped under a single result element, &lt;code&gt;CommonPrefixes&lt;/code&gt;. If you don&#39;t specify the prefix parameter, then the substring starts at the beginning of the key. The keys that are grouped under &lt;code&gt;CommonPrefixes&lt;/code&gt; result element are not returned elsewhere in the response.&lt;/p&gt;
func (r ApiListMultipartUploadsRequest) Delimiter(delimiter string) ApiListMultipartUploadsRequest {
	r.delimiter = &delimiter
	return r
}

// 
func (r ApiListMultipartUploadsRequest) EncodingType(encodingType string) ApiListMultipartUploadsRequest {
	r.encodingType = &encodingType
	return r
}

// &lt;p&gt;Together with upload-id-marker, this parameter specifies the multipart upload after which listing should begin.&lt;/p&gt; &lt;p&gt;If &lt;code&gt;upload-id-marker&lt;/code&gt; is not specified, only the keys lexicographically greater than the specified &lt;code&gt;key-marker&lt;/code&gt; will be included in the list.&lt;/p&gt; &lt;p&gt;If &lt;code&gt;upload-id-marker&lt;/code&gt; is specified, any multipart uploads for a key equal to the &lt;code&gt;key-marker&lt;/code&gt; might also be included, provided those multipart uploads have upload IDs lexicographically greater than the specified &lt;code&gt;upload-id-marker&lt;/code&gt;.&lt;/p&gt;
func (r ApiListMultipartUploadsRequest) KeyMarker(keyMarker string) ApiListMultipartUploadsRequest {
	r.keyMarker = &keyMarker
	return r
}

// Sets the maximum number of multipart uploads, from 1 to 1,000, to return in the response body. 1,000 is the maximum number of uploads that can be returned in a response.
func (r ApiListMultipartUploadsRequest) MaxUploads(maxUploads int32) ApiListMultipartUploadsRequest {
	r.maxUploads = &maxUploads
	return r
}

// Lists in-progress uploads only for those keys that begin with the specified prefix. You can use prefixes to separate a bucket into different grouping of keys. (You can think of using prefix to make groups in the same way you&#39;d use a folder in a file system.)
func (r ApiListMultipartUploadsRequest) Prefix(prefix string) ApiListMultipartUploadsRequest {
	r.prefix = &prefix
	return r
}

// Together with key-marker, specifies the multipart upload after which listing should begin. If key-marker is not specified, the upload-id-marker parameter is ignored. Otherwise, any multipart uploads for a key equal to the key-marker might be included in the list only if they have an upload ID lexicographically greater than the specified &lt;code&gt;upload-id-marker&lt;/code&gt;.
func (r ApiListMultipartUploadsRequest) UploadIdMarker(uploadIdMarker string) ApiListMultipartUploadsRequest {
	r.uploadIdMarker = &uploadIdMarker
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiListMultipartUploadsRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiListMultipartUploadsRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

// Pagination limit
func (r ApiListMultipartUploadsRequest) MaxUploads2(maxUploads2 string) ApiListMultipartUploadsRequest {
	r.maxUploads2 = &maxUploads2
	return r
}

// Pagination token
func (r ApiListMultipartUploadsRequest) KeyMarker2(keyMarker2 string) ApiListMultipartUploadsRequest {
	r.keyMarker2 = &keyMarker2
	return r
}

// Pagination token
func (r ApiListMultipartUploadsRequest) UploadIdMarker2(uploadIdMarker2 string) ApiListMultipartUploadsRequest {
	r.uploadIdMarker2 = &uploadIdMarker2
	return r
}

func (r ApiListMultipartUploadsRequest) Execute() (*ListMultipartUploadsOutput, *http.Response, error) {
	return r.ApiService.ListMultipartUploadsExecute(r)
}

/*
ListMultipartUploads Method for ListMultipartUploads

<p>This action lists in-progress multipart uploads. An in-progress multipart upload is a multipart upload that has been initiated using the Initiate Multipart Upload request, but has not yet been completed or aborted.</p> <p>This action returns at most 1,000 multipart uploads in the response. 1,000 multipart uploads is the maximum number of uploads a response can include, which is also the default value. You can further limit the number of uploads in a response by specifying the <code>max-uploads</code> parameter in the response. If additional multipart uploads satisfy the list criteria, the response will contain an <code>IsTruncated</code> element with the value true. To list the additional multipart uploads, use the <code>key-marker</code> and <code>upload-id-marker</code> request parameters.</p> <p>In the response, the uploads are sorted by key. If your application has initiated more than one multipart upload using the same object key, then uploads in the response are first sorted by key. Additionally, uploads are sorted in ascending order within each key by the upload initiation time.</p> <p>For more information on multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/uploadobjusingmpu.html">Uploading Objects Using Multipart Upload</a>.</p> <p>For information on permissions required to use the multipart upload API, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuAndPermissions.html">Multipart Upload and Permissions</a>.</p> <p>The following operations are related to <code>ListMultipartUploads</code>:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html">CreateMultipartUpload</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPart.html">UploadPart</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CompleteMultipartUpload.html">CompleteMultipartUpload</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListParts.html">ListParts</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_AbortMultipartUpload.html">AbortMultipartUpload</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The name of the bucket to which the multipart upload was initiated. </p>
 @return ApiListMultipartUploadsRequest
*/
func (a *MultipartAPIService) ListMultipartUploads(ctx context.Context, bucket string) ApiListMultipartUploadsRequest {
	return ApiListMultipartUploadsRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
	}
}

// Execute executes the request
//  @return ListMultipartUploadsOutput
func (a *MultipartAPIService) ListMultipartUploadsExecute(r ApiListMultipartUploadsRequest) (*ListMultipartUploadsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMultipartUploadsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultipartAPIService.ListMultipartUploads")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}#uploads"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uploads == nil {
		return localVarReturnValue, nil, reportError("uploads is required and must be specified")
	}

	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "")
	}
	if r.encodingType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encoding-type", r.encodingType, "")
	}
	if r.keyMarker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key-marker", r.keyMarker, "")
	}
	if r.maxUploads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-uploads", r.maxUploads, "")
	}
	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "")
	}
	if r.uploadIdMarker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upload-id-marker", r.uploadIdMarker, "")
	}
	if r.maxUploads2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxUploads", r.maxUploads2, "")
	}
	if r.keyMarker2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeyMarker", r.keyMarker2, "")
	}
	if r.uploadIdMarker2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UploadIdMarker", r.uploadIdMarker2, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uploads", r.uploads, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPartsRequest struct {
	ctx context.Context
	ApiService *MultipartAPIService
	bucket string
	key string
	uploadId *string
	xAmzSecurityToken *string
	maxParts *int32
	partNumberMarker *int32
	xAmzRequestPayer *string
	xAmzExpectedBucketOwner *string
	maxParts2 *string
	partNumberMarker2 *string
}

// Upload ID identifying the multipart upload whose parts are being listed.
func (r ApiListPartsRequest) UploadId(uploadId string) ApiListPartsRequest {
	r.uploadId = &uploadId
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiListPartsRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiListPartsRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// Sets the maximum number of parts to return.
func (r ApiListPartsRequest) MaxParts(maxParts int32) ApiListPartsRequest {
	r.maxParts = &maxParts
	return r
}

// Specifies the part after which listing should begin. Only parts with higher part numbers will be listed.
func (r ApiListPartsRequest) PartNumberMarker(partNumberMarker int32) ApiListPartsRequest {
	r.partNumberMarker = &partNumberMarker
	return r
}

// 
func (r ApiListPartsRequest) XAmzRequestPayer(xAmzRequestPayer string) ApiListPartsRequest {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiListPartsRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiListPartsRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

// Pagination limit
func (r ApiListPartsRequest) MaxParts2(maxParts2 string) ApiListPartsRequest {
	r.maxParts2 = &maxParts2
	return r
}

// Pagination token
func (r ApiListPartsRequest) PartNumberMarker2(partNumberMarker2 string) ApiListPartsRequest {
	r.partNumberMarker2 = &partNumberMarker2
	return r
}

func (r ApiListPartsRequest) Execute() (*ListPartsOutput, *http.Response, error) {
	return r.ApiService.ListPartsExecute(r)
}

/*
ListParts Method for ListParts

<p>Lists the parts that have been uploaded for a specific multipart upload. This operation must include the upload ID, which you obtain by sending the initiate multipart upload request (see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html">CreateMultipartUpload</a>). This request returns a maximum of 1,000 uploaded parts. The default number of parts returned is 1,000 parts. You can restrict the number of parts returned by specifying the <code>max-parts</code> request parameter. If your multipart upload consists of more than 1,000 parts, the response returns an <code>IsTruncated</code> field with the value of true, and a <code>NextPartNumberMarker</code> element. In subsequent <code>ListParts</code> requests you can include the part-number-marker query string parameter and set its value to the <code>NextPartNumberMarker</code> field value from the previous response.</p> <p>For more information on multipart uploads, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/uploadobjusingmpu.html">Uploading Objects Using Multipart Upload</a>.</p> <p>For information on permissions required to use the multipart upload API, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuAndPermissions.html">Multipart Upload and Permissions</a>.</p> <p>The following operations are related to <code>ListParts</code>:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html">CreateMultipartUpload</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPart.html">UploadPart</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CompleteMultipartUpload.html">CompleteMultipartUpload</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_AbortMultipartUpload.html">AbortMultipartUpload</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListMultipartUploads.html">ListMultipartUploads</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The name of the bucket to which the parts are being uploaded. </p> </p>
 @param key Object key for which the multipart upload was initiated.
 @return ApiListPartsRequest
*/
func (a *MultipartAPIService) ListParts(ctx context.Context, bucket string, key string) ApiListPartsRequest {
	return ApiListPartsRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
		key: key,
	}
}

// Execute executes the request
//  @return ListPartsOutput
func (a *MultipartAPIService) ListPartsExecute(r ApiListPartsRequest) (*ListPartsOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPartsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultipartAPIService.ListParts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}#uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}

	if r.maxParts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-parts", r.maxParts, "")
	}
	if r.partNumberMarker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "part-number-marker", r.partNumberMarker, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	if r.maxParts2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxParts", r.maxParts2, "")
	}
	if r.partNumberMarker2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PartNumberMarker", r.partNumberMarker2, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadPartRequest struct {
	ctx context.Context
	ApiService *MultipartAPIService
	bucket string
	key string
	partNumber *int32
	uploadId *string
	uploadPartRequest *UploadPartRequest
	xAmzSecurityToken *string
	contentLength *int32
	contentMD5 *string
	xAmzServerSideEncryptionCustomerAlgorithm *string
	xAmzServerSideEncryptionCustomerKey *string
	xAmzServerSideEncryptionCustomerKeyMD5 *string
	xAmzRequestPayer *string
	xAmzExpectedBucketOwner *string
}

// Part number of part being uploaded. This is a positive integer between 1 and 10,000.
func (r ApiUploadPartRequest) PartNumber(partNumber int32) ApiUploadPartRequest {
	r.partNumber = &partNumber
	return r
}

// Upload ID identifying the multipart upload whose part is being uploaded.
func (r ApiUploadPartRequest) UploadId(uploadId string) ApiUploadPartRequest {
	r.uploadId = &uploadId
	return r
}

func (r ApiUploadPartRequest) UploadPartRequest(uploadPartRequest UploadPartRequest) ApiUploadPartRequest {
	r.uploadPartRequest = &uploadPartRequest
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiUploadPartRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiUploadPartRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// Size of the body in bytes. This parameter is useful when the size of the body cannot be determined automatically.
func (r ApiUploadPartRequest) ContentLength(contentLength int32) ApiUploadPartRequest {
	r.contentLength = &contentLength
	return r
}

// The base64-encoded 128-bit MD5 digest of the part data. This parameter is auto-populated when using the command from the CLI. This parameter is required if object lock parameters are specified.
func (r ApiUploadPartRequest) ContentMD5(contentMD5 string) ApiUploadPartRequest {
	r.contentMD5 = &contentMD5
	return r
}

// Specifies the algorithm to use to when encrypting the object (for example, AES256).
func (r ApiUploadPartRequest) XAmzServerSideEncryptionCustomerAlgorithm(xAmzServerSideEncryptionCustomerAlgorithm string) ApiUploadPartRequest {
	r.xAmzServerSideEncryptionCustomerAlgorithm = &xAmzServerSideEncryptionCustomerAlgorithm
	return r
}

// Specifies the customer-provided encryption key for ArvanCloud S3 to use in encrypting data. This value is used to store the object and then it is discarded; ArvanCloud S3 does not store the encryption key. The key must be appropriate for use with the algorithm specified in the &lt;code&gt;x-amz-server-side-encryption-customer-algorithm header&lt;/code&gt;. This must be the same encryption key specified in the initiate multipart upload request.
func (r ApiUploadPartRequest) XAmzServerSideEncryptionCustomerKey(xAmzServerSideEncryptionCustomerKey string) ApiUploadPartRequest {
	r.xAmzServerSideEncryptionCustomerKey = &xAmzServerSideEncryptionCustomerKey
	return r
}

// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. ArvanCloud S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
func (r ApiUploadPartRequest) XAmzServerSideEncryptionCustomerKeyMD5(xAmzServerSideEncryptionCustomerKeyMD5 string) ApiUploadPartRequest {
	r.xAmzServerSideEncryptionCustomerKeyMD5 = &xAmzServerSideEncryptionCustomerKeyMD5
	return r
}

// 
func (r ApiUploadPartRequest) XAmzRequestPayer(xAmzRequestPayer string) ApiUploadPartRequest {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiUploadPartRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiUploadPartRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiUploadPartRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UploadPartExecute(r)
}

/*
UploadPart Method for UploadPart

<p>Uploads a part in a multipart upload.</p> <note> <p>In this operation, you provide part data in your request. However, you have an option to specify your existing ArvanCloud S3 object as a data source for the part you are uploading. To upload a part from an existing object, you use the <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPartCopy.html">UploadPartCopy</a> operation. </p> </note> <p>You must initiate a multipart upload (see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html">CreateMultipartUpload</a>) before you can upload any part. In response to your initiate request, ArvanCloud S3 returns an upload ID, a unique identifier, that you must include in your upload part request.</p> <p>Part numbers can be any number from 1 to 10,000, inclusive. A part number uniquely identifies a part and also defines its position within the object being created. If you upload a new part using the same part number that was used with a previous part, the previously uploaded part is overwritten. Each part must be at least 5 MB in size, except the last part. There is no size limit on the last part of your multipart upload.</p> <p>To ensure that data is not corrupted when traversing the network, specify the <code>Content-MD5</code> header in the upload part request. ArvanCloud S3 checks the part data against the provided MD5 value. If they do not match, ArvanCloud S3 returns an error. </p> <p>If the upload request is signed with Signature Version 4, then Amazon Web Services S3 uses the <code>x-amz-content-sha256</code> header as a checksum instead of <code>Content-MD5</code>. For more information see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-auth-using-authorization-header.html">Authenticating Requests: Using the Authorization Header (Amazon Web Services Signature Version 4)</a>. </p> <p> <b>Note:</b> After you initiate multipart upload and upload one or more parts, you must either complete or abort multipart upload in order to stop getting charged for storage of the uploaded parts. Only after you either complete or abort multipart upload, ArvanCloud S3 frees up the parts storage and stops charging you for the parts storage.</p> <p>For more information on multipart uploads, go to <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html">Multipart Upload Overview</a> in the <i>S3 User Guide </i>.</p> <p>For information on the permissions required to use the multipart upload API, go to <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuAndPermissions.html">Multipart Upload and Permissions</a> in the <i>S3 User Guide</i>.</p> <p>You can optionally request server-side encryption where ArvanCloud S3 encrypts your data as it writes it to disks in its data centers and decrypts it for you when you access it. You have the option of providing your own encryption key, or you can use the Amazon Web Services managed encryption keys. If you choose to provide your own encryption key, the request headers you provide in the request must match the headers you used in the request to initiate the upload by using <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html">CreateMultipartUpload</a>. For more information, go to <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html">Using Server-Side Encryption</a> in the <i>S3 User Guide</i>.</p> <p>Server-side encryption is supported by the S3 Multipart Upload actions. Unless you are using a customer-provided encryption key, you don't need to specify the encryption parameters in each UploadPart request. Instead, you only need to specify the server-side encryption parameters in the initial Initiate Multipart request. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html">CreateMultipartUpload</a>.</p> <p>If you requested server-side encryption using a customer-provided encryption key in your initiate multipart upload request, you must provide identical encryption information in each part upload using the following headers.</p> <ul> <li> <p>x-amz-server-side-encryption-customer-algorithm</p> </li> <li> <p>x-amz-server-side-encryption-customer-key</p> </li> <li> <p>x-amz-server-side-encryption-customer-key-MD5</p> </li> </ul> <p class="title"> <b>Special Errors</b> </p> <ul> <li> <ul> <li> <p> <i>Code: NoSuchUpload</i> </p> </li> <li> <p> <i>Cause: The specified multipart upload does not exist. The upload ID might be invalid, or the multipart upload might have been aborted or completed.</i> </p> </li> <li> <p> <i> HTTP Status Code: 404 Not Found </i> </p> </li> <li> <p> <i>SOAP Fault Code Prefix: Client</i> </p> </li> </ul> </li> </ul> <p class="title"> <b>Related Resources</b> </p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html">CreateMultipartUpload</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_CompleteMultipartUpload.html">CompleteMultipartUpload</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_AbortMultipartUpload.html">AbortMultipartUpload</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListParts.html">ListParts</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListMultipartUploads.html">ListMultipartUploads</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The name of the bucket to which the multipart upload was initiated.</p> </p>
 @param key Object key for which the multipart upload was initiated.
 @return ApiUploadPartRequest
*/
func (a *MultipartAPIService) UploadPart(ctx context.Context, bucket string, key string) ApiUploadPartRequest {
	return ApiUploadPartRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
		key: key,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MultipartAPIService) UploadPartExecute(r ApiUploadPartRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MultipartAPIService.UploadPart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}#partNumber&uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.partNumber == nil {
		return localVarReturnValue, nil, reportError("partNumber is required and must be specified")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}
	if r.uploadPartRequest == nil {
		return localVarReturnValue, nil, reportError("uploadPartRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "partNumber", r.partNumber, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.contentLength != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Length", r.contentLength, "")
	}
	if r.contentMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-MD5", r.contentMD5, "")
	}
	if r.xAmzServerSideEncryptionCustomerAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-algorithm", r.xAmzServerSideEncryptionCustomerAlgorithm, "")
	}
	if r.xAmzServerSideEncryptionCustomerKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key", r.xAmzServerSideEncryptionCustomerKey, "")
	}
	if r.xAmzServerSideEncryptionCustomerKeyMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key-MD5", r.xAmzServerSideEncryptionCustomerKeyMD5, "")
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	// body params
	localVarPostBody = r.uploadPartRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
