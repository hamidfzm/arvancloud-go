/*
ArvanCloud S3 Services

<p/>

API version: 2006-03-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package storage

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ObjectTaggingAPIService ObjectTaggingAPI service
type ObjectTaggingAPIService service

type ApiDeleteObjectTaggingRequest struct {
	ctx context.Context
	ApiService *ObjectTaggingAPIService
	bucket string
	key string
	tagging *bool
	xAmzSecurityToken *string
	versionId *string
	xAmzExpectedBucketOwner *string
}

func (r ApiDeleteObjectTaggingRequest) Tagging(tagging bool) ApiDeleteObjectTaggingRequest {
	r.tagging = &tagging
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiDeleteObjectTaggingRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiDeleteObjectTaggingRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// The versionId of the object that the tag-set will be removed from.
func (r ApiDeleteObjectTaggingRequest) VersionId(versionId string) ApiDeleteObjectTaggingRequest {
	r.versionId = &versionId
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiDeleteObjectTaggingRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiDeleteObjectTaggingRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

func (r ApiDeleteObjectTaggingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteObjectTaggingExecute(r)
}

/*
DeleteObjectTagging Method for DeleteObjectTagging

<p>Removes the entire tag set from the specified object. For more information about managing object tags, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-tagging.html"> Object Tagging</a>.</p> <p>To use this operation, you must have permission to perform the <code>s3:DeleteObjectTagging</code> action.</p> <p>To delete tags of a specific object version, add the <code>versionId</code> query parameter in the request. You will need permission for the <code>s3:DeleteObjectVersionTagging</code> action.</p> <p>The following operations are related to <code>DeleteBucketMetricsConfiguration</code>:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObjectTagging.html">PutObjectTagging</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObjectTagging.html">GetObjectTagging</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The bucket name containing the objects from which to remove the tags. </p>
 @param key The key that identifies the object in the bucket from which to remove all tags.
 @return ApiDeleteObjectTaggingRequest
*/
func (a *ObjectTaggingAPIService) DeleteObjectTagging(ctx context.Context, bucket string, key string) ApiDeleteObjectTaggingRequest {
	return ApiDeleteObjectTaggingRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
		key: key,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ObjectTaggingAPIService) DeleteObjectTaggingExecute(r ApiDeleteObjectTaggingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectTaggingAPIService.DeleteObjectTagging")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}#tagging"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.tagging == nil {
		return localVarReturnValue, nil, reportError("tagging is required and must be specified")
	}

	if r.versionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionId", r.versionId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "tagging", r.tagging, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetObjectTaggingRequest struct {
	ctx context.Context
	ApiService *ObjectTaggingAPIService
	bucket string
	key string
	tagging *bool
	xAmzSecurityToken *string
	versionId *string
	xAmzExpectedBucketOwner *string
	xAmzRequestPayer *string
}

func (r ApiGetObjectTaggingRequest) Tagging(tagging bool) ApiGetObjectTaggingRequest {
	r.tagging = &tagging
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiGetObjectTaggingRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiGetObjectTaggingRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// The versionId of the object for which to get the tagging information.
func (r ApiGetObjectTaggingRequest) VersionId(versionId string) ApiGetObjectTaggingRequest {
	r.versionId = &versionId
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiGetObjectTaggingRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiGetObjectTaggingRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

// 
func (r ApiGetObjectTaggingRequest) XAmzRequestPayer(xAmzRequestPayer string) ApiGetObjectTaggingRequest {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

func (r ApiGetObjectTaggingRequest) Execute() (*GetObjectTaggingOutput, *http.Response, error) {
	return r.ApiService.GetObjectTaggingExecute(r)
}

/*
GetObjectTagging Method for GetObjectTagging

<p>Returns the tag-set of an object. You send the GET request against the tagging subresource associated with the object.</p> <p>To use this operation, you must have permission to perform the <code>s3:GetObjectTagging</code> action. By default, the GET action returns information about current version of an object. For a versioned bucket, you can have multiple versions of an object in your bucket. To retrieve tags of any other version, use the versionId query parameter. You also need permission for the <code>s3:GetObjectVersionTagging</code> action.</p> <p> By default, the bucket owner has this permission and can grant this permission to others.</p> <p> For information about the ArvanCloud S3 object tagging feature, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-tagging.html">Object Tagging</a>.</p> <p>The following action is related to <code>GetObjectTagging</code>:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObjectTagging.html">PutObjectTagging</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_DeleteObjectTagging.html">DeleteObjectTagging</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The bucket name containing the object for which to get the tagging information. </p> </p>
 @param key Object key for which to get the tagging information.
 @return ApiGetObjectTaggingRequest
*/
func (a *ObjectTaggingAPIService) GetObjectTagging(ctx context.Context, bucket string, key string) ApiGetObjectTaggingRequest {
	return ApiGetObjectTaggingRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
		key: key,
	}
}

// Execute executes the request
//  @return GetObjectTaggingOutput
func (a *ObjectTaggingAPIService) GetObjectTaggingExecute(r ApiGetObjectTaggingRequest) (*GetObjectTaggingOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetObjectTaggingOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectTaggingAPIService.GetObjectTagging")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}#tagging"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.tagging == nil {
		return localVarReturnValue, nil, reportError("tagging is required and must be specified")
	}

	if r.versionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionId", r.versionId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "tagging", r.tagging, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutObjectTaggingRequest struct {
	ctx context.Context
	ApiService *ObjectTaggingAPIService
	bucket string
	key string
	tagging *bool
	putBucketTaggingRequest *PutBucketTaggingRequest
	xAmzSecurityToken *string
	versionId *string
	contentMD5 *string
	xAmzExpectedBucketOwner *string
	xAmzRequestPayer *string
}

func (r ApiPutObjectTaggingRequest) Tagging(tagging bool) ApiPutObjectTaggingRequest {
	r.tagging = &tagging
	return r
}

func (r ApiPutObjectTaggingRequest) PutBucketTaggingRequest(putBucketTaggingRequest PutBucketTaggingRequest) ApiPutObjectTaggingRequest {
	r.putBucketTaggingRequest = &putBucketTaggingRequest
	return r
}

// This parameter is currently not supported and is not required.
func (r ApiPutObjectTaggingRequest) XAmzSecurityToken(xAmzSecurityToken string) ApiPutObjectTaggingRequest {
	r.xAmzSecurityToken = &xAmzSecurityToken
	return r
}

// The versionId of the object that the tag-set will be added to.
func (r ApiPutObjectTaggingRequest) VersionId(versionId string) ApiPutObjectTaggingRequest {
	r.versionId = &versionId
	return r
}

// &lt;p&gt;The MD5 hash for the request body.&lt;/p&gt; &lt;p&gt;For requests made using the Amazon Web Services Command Line Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically.&lt;/p&gt;
func (r ApiPutObjectTaggingRequest) ContentMD5(contentMD5 string) ApiPutObjectTaggingRequest {
	r.contentMD5 = &contentMD5
	return r
}

// The account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP &lt;code&gt;403 (Access Denied)&lt;/code&gt; error.
func (r ApiPutObjectTaggingRequest) XAmzExpectedBucketOwner(xAmzExpectedBucketOwner string) ApiPutObjectTaggingRequest {
	r.xAmzExpectedBucketOwner = &xAmzExpectedBucketOwner
	return r
}

// 
func (r ApiPutObjectTaggingRequest) XAmzRequestPayer(xAmzRequestPayer string) ApiPutObjectTaggingRequest {
	r.xAmzRequestPayer = &xAmzRequestPayer
	return r
}

func (r ApiPutObjectTaggingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PutObjectTaggingExecute(r)
}

/*
PutObjectTagging Method for PutObjectTagging

<p>Sets the supplied tag-set to an object that already exists in a bucket.</p> <p>A tag is a key-value pair. You can associate tags with an object by sending a PUT request against the tagging subresource that is associated with the object. You can retrieve tags by sending a GET request. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObjectTagging.html">GetObjectTagging</a>.</p> <p>For tagging-related restrictions related to characters and encodings, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/allocation-tag-restrictions.html">Tag Restrictions</a>. Note that ArvanCloud S3 limits the maximum number of tags to 10 tags per object.</p> <p>To use this operation, you must have permission to perform the <code>s3:PutObjectTagging</code> action. By default, the bucket owner has this permission and can grant this permission to others.</p> <p>To put tags of any other version, use the <code>versionId</code> query parameter. You also need permission for the <code>s3:PutObjectVersionTagging</code> action.</p> <p>For information about the ArvanCloud S3 object tagging feature, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-tagging.html">Object Tagging</a>.</p> <p class="title"> <b>Special Errors</b> </p> <ul> <li> <ul> <li> <p> <i>Code: InvalidTagError </i> </p> </li> <li> <p> <i>Cause: The tag provided was not a valid tag. This error can occur if the tag did not pass input validation. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-tagging.html">Object Tagging</a>.</i> </p> </li> </ul> </li> <li> <ul> <li> <p> <i>Code: MalformedXMLError </i> </p> </li> <li> <p> <i>Cause: The XML provided does not match the schema.</i> </p> </li> </ul> </li> <li> <ul> <li> <p> <i>Code: OperationAbortedError </i> </p> </li> <li> <p> <i>Cause: A conflicting conditional action is currently in progress against this resource. Please try again.</i> </p> </li> </ul> </li> <li> <ul> <li> <p> <i>Code: InternalError</i> </p> </li> <li> <p> <i>Cause: The service was unable to apply the provided tag to the object.</i> </p> </li> </ul> </li> </ul> <p class="title"> <b>Related Resources</b> </p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObjectTagging.html">GetObjectTagging</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_DeleteObjectTagging.html">DeleteObjectTagging</a> </p> </li> </ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucket <p>The bucket name containing the object. </p> </p>
 @param key Name of the object key.
 @return ApiPutObjectTaggingRequest
*/
func (a *ObjectTaggingAPIService) PutObjectTagging(ctx context.Context, bucket string, key string) ApiPutObjectTaggingRequest {
	return ApiPutObjectTaggingRequest{
		ApiService: a,
		ctx: ctx,
		bucket: bucket,
		key: key,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ObjectTaggingAPIService) PutObjectTaggingExecute(r ApiPutObjectTaggingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectTaggingAPIService.PutObjectTagging")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}#tagging"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", url.PathEscape(parameterValueToString(r.bucket, "bucket")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.tagging == nil {
		return localVarReturnValue, nil, reportError("tagging is required and must be specified")
	}
	if r.putBucketTaggingRequest == nil {
		return localVarReturnValue, nil, reportError("putBucketTaggingRequest is required and must be specified")
	}

	if r.versionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionId", r.versionId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "tagging", r.tagging, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAmzSecurityToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-security-token", r.xAmzSecurityToken, "")
	}
	if r.contentMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-MD5", r.contentMD5, "")
	}
	if r.xAmzExpectedBucketOwner != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-expected-bucket-owner", r.xAmzExpectedBucketOwner, "")
	}
	if r.xAmzRequestPayer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-request-payer", r.xAmzRequestPayer, "")
	}
	// body params
	localVarPostBody = r.putBucketTaggingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
